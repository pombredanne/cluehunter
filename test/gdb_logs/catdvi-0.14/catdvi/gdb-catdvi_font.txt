Temporary breakpoint 1 at 0x8048c10: file catdvi.c, line 57.
Starting program: /home/yangke/Program/Fabian-Yamaguchi/evdata/catdvi/catdvi-0.14/catdvi-pipline/catdvi -U ./exploit_0_0 >out

Temporary breakpoint 1, main (argc=3, argv=0xbfffe864) at catdvi.c:57
57	{
74	        setlocale(LC_ALL, "");
57	{
74	        setlocale(LC_ALL, "");
83	        setup_findtfm(argv[0]);
76	        msglevel = 10; /* Level of verbosity for pmesg */ 
83	        setup_findtfm(argv[0]);
setup_findtfm (
    progname=0xbfffeaab "/home/yangke/Program/Fabian-Yamaguchi/evdata/catdvi/catdvi-0.14/catdvi-pipline/catdvi") at kpathsea.c:25
25	{
26	        kpse_set_program_name(progname, PACKAGE);
27	        kpse_init_format(kpse_tfm_format);
28	        kpse_set_program_enabled(kpse_tfm_format, 1, kpse_src_cmdline);
29	}
main (argc=3, argv=0xbfffe864) at catdvi.c:89
89	                opt = getopt_long(argc, argv, shopt, lopt, 0);
90	                if (opt == -1) break;
92	                switch (opt) {
186	                        outenc_show_unicode_number = 1;
187	                        break;
89	                opt = getopt_long(argc, argv, shopt, lopt, 0);
90	                if (opt == -1) break;
222	        if ((argc-optind != 0) && (argc-optind != 1)) {
227	        if ((argc-optind == 0) || ((argc-optind == 1) && !strcmp(argv[optind], "-"))) {
230	                dvifile = fopen(argv[optind], "rb");
231	                if (!dvifile)
230	                dvifile = fopen(argv[optind], "rb");
231	                if (!dvifile)
236	    	glyphops_init();
glyphops_init () at glyphops.c:276
276	{
284	    for(ph = hints; ph->glyph != 0; ++ph) {
276	{
283	    spars32_init(&hint_spars32, 0);
spars32_init (this=this@entry=0x806c00c <hint_spars32>, 
    default_value=default_value@entry=0) at sparse.c:192
192	void spars32_init(spars32_t * this, sint32 default_value) {
196	    spar_init(&this->s32_spar, default_leaf);
spar_init (default_entry=..., this=this@entry=0x806c00c <hint_spars32>)
    at sparse.c:58
58	    this->height = 0;
59	    this->max_shift = - SPAR_BITS_PER_STAGE;
60	    this->max_index = 0;
61	    this->default_leaf = default_entry;
64	    this->root = default_entry;
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=94)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=<optimized out>) at sparse.c:161
161	    	p = spar_new_block(default_branch);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=94)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806c00c <hint_spars32>) at sparse.c:157
157	    if(this->height ==  0) {
158	    	p = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_grow (this=0x806c00c <hint_spars32>) at sparse.c:163
163	    p[0] = this->root;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
163	    p[0] = this->root;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
164	    this->root.children = p;
167	    this->height += 1;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
170	    	| SPAR_STAGE_MASK;
167	    this->height += 1;
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=94)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806c00c <hint_spars32>) at sparse.c:167
167	    this->height += 1;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=94)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=96)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=96)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=126)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=126)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=168)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=168)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=175)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=175)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=180)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=180)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=184)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=184)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=710)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=<optimized out>) at sparse.c:161
161	    	p = spar_new_block(default_branch);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=710)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806c00c <hint_spars32>) at sparse.c:157
157	    if(this->height ==  0) {
spar_new_block (fill_with=fill_with@entry=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=..., fill_with@entry=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_grow (this=0x806c00c <hint_spars32>) at sparse.c:163
163	    p[0] = this->root;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
163	    p[0] = this->root;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
164	    this->root.children = p;
167	    this->height += 1;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
170	    	| SPAR_STAGE_MASK;
167	    this->height += 1;
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=710)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806c00c <hint_spars32>) at sparse.c:167
167	    this->height += 1;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=710)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=710)
    at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=711)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=711)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=713)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=713)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=714)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=714)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=715)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=715)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=728)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=728)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=729)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=729)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=730)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=730)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=731)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=731)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=732)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=732)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114104)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=<optimized out>) at sparse.c:161
161	    	p = spar_new_block(default_branch);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114104)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806c00c <hint_spars32>) at sparse.c:157
157	    if(this->height ==  0) {
spar_new_block (fill_with=fill_with@entry=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=..., fill_with@entry=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_grow (this=0x806c00c <hint_spars32>) at sparse.c:163
163	    p[0] = this->root;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
163	    p[0] = this->root;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
164	    this->root.children = p;
167	    this->height += 1;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
170	    	| SPAR_STAGE_MASK;
167	    this->height += 1;
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114104)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806c00c <hint_spars32>) at sparse.c:167
167	    this->height += 1;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114104)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
109		    	p->children = spar_new_block(default_branch);
spar_new_block (fill_with=fill_with@entry=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=..., fill_with@entry=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114104)
    at sparse.c:110
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
109		    	p->children = spar_new_block(default_branch);
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114104)
    at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114108)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114108)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=9711)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=9711)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=9711)
    at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114107)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114107)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=768)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=768)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=768)
    at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=769)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=769)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=770)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=770)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=771)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=771)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=772)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=772)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=773)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=773)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=774)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=774)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=775)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=775)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=776)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=776)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=777)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=777)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=778)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=778)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=780)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=780)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=807)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=807)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=808)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=808)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114103)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114103)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=824)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=824)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=8413)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=8413)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=8413)
    at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=8407)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=8407)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63208)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63208)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63208)
    at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114106)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114106)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114105)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114105)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=8730)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=8730)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=8730)
    at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113856)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113856)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113857)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113857)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113858)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113858)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113859)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113859)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113860)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113860)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113861)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113861)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113862)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113862)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113863)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113863)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113864)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113864)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113865)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113865)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113866)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113866)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113867)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113867)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113868)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113868)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113869)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113869)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113870)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113870)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113871)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113871)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113872)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113872)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113873)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113873)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113874)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113874)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113875)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113875)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113876)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113876)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113877)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113877)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113878)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113878)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113879)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113879)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113880)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113880)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113881)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113881)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113882)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113882)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113883)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113883)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113884)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113884)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113885)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113885)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113886)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113886)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113887)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113887)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113888)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113888)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113889)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113889)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113890)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113890)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113891)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113891)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113892)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113892)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113893)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113893)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113894)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113894)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113895)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113895)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113896)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113896)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113897)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113897)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113898)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113898)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113899)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113899)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113900)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113900)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113901)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113901)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113902)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113902)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113903)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113903)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63723)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63723)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63723)
    at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63734)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63734)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63726)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63726)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63737)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63737)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63728)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63728)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63739)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63739)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63727)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63727)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63738)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63738)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63729)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63729)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63740)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63740)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63731)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63731)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63742)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63742)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63730)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63730)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63741)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63741)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63732)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63732)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63718)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63718)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63725)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63725)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63736)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63736)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63724)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63724)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63735)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=63735)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113924)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113924)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113925)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113925)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113926)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113926)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113927)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113927)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113928)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113928)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113929)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113929)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113930)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113930)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113931)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113931)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113932)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113932)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113933)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113933)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113934)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113934)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113935)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113935)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113936)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113936)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113937)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113937)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113938)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113938)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113939)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113939)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113940)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113940)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113941)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113941)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113942)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113942)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113943)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113943)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113944)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113944)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113945)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113945)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113946)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113946)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113947)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113947)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113948)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113948)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113949)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113949)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113950)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113950)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113951)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113951)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113952)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113952)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113953)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113953)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113954)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113954)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113955)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113955)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113956)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113956)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113957)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113957)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113958)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113958)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113959)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113959)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113960)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113960)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113961)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113961)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113962)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113962)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113963)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113963)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113964)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113964)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113965)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113965)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113966)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113966)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113967)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113967)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113968)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113968)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113969)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113969)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113970)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113970)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113971)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113971)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113972)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113972)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113973)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113973)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113974)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113974)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113975)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113975)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113976)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113976)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113977)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113977)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113979)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113979)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113981)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113981)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113982)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113982)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113983)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1113983)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114096)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114096)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
284	    for(ph = hints; ph->glyph != 0; ++ph) {
285	    	spars32_write(&hint_spars32, ph->glyph, ph->hint);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114095)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806c00c <hint_spars32>, i=1114095)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:284
284	    for(ph = hints; ph->glyph != 0; ++ph) {
291	    sparp_init(&diavar_sparp);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
291	    sparp_init(&diavar_sparp);
sparp_init (this=this@entry=0x806bff8 <diavar_sparp>) at sparse.c:177
177	void sparp_init(sparp_t * this) {
181	    spar_init(&this->p_spar, default_leaf);
spar_init (default_entry=..., this=this@entry=0x806bff8 <diavar_sparp>)
    at sparse.c:58
58	    this->height = 0;
59	    this->max_shift = - SPAR_BITS_PER_STAGE;
60	    this->max_index = 0;
61	    this->default_leaf = default_entry;
64	    this->root = default_entry;
glyphops_init () at glyphops.c:292
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=180)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=<optimized out>) at sparse.c:161
161	    	p = spar_new_block(default_branch);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=180)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bff8 <diavar_sparp>) at sparse.c:157
157	    if(this->height ==  0) {
158	    	p = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_grow (this=0x806bff8 <diavar_sparp>) at sparse.c:163
163	    p[0] = this->root;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
163	    p[0] = this->root;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
164	    this->root.children = p;
167	    this->height += 1;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
170	    	| SPAR_STAGE_MASK;
167	    this->height += 1;
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=180)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bff8 <diavar_sparp>) at sparse.c:167
167	    this->height += 1;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=180)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=769)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=<optimized out>) at sparse.c:161
161	    	p = spar_new_block(default_branch);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=769)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bff8 <diavar_sparp>) at sparse.c:157
157	    if(this->height ==  0) {
spar_new_block (fill_with=fill_with@entry=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=..., fill_with@entry=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_grow (this=0x806bff8 <diavar_sparp>) at sparse.c:163
163	    p[0] = this->root;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
163	    p[0] = this->root;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
164	    this->root.children = p;
167	    this->height += 1;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
170	    	| SPAR_STAGE_MASK;
167	    this->height += 1;
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=769)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bff8 <diavar_sparp>) at sparse.c:167
167	    this->height += 1;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=769)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=769)
    at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=714)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=714)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=714)
    at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
glyphops_init () at glyphops.c:296
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=96)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=96)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=768)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=768)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=715)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=715)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:296
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=94)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=94)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=770)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=770)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=710)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=710)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:296
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=168)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=168)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=776)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=776)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=732)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=732)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=771)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=771)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=126)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=126)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:296
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=730)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=730)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=778)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=778)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=184)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=184)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=807)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=807)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=711)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=711)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=780)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=780)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=175)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=175)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=772)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=772)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=713)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=713)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:296
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=728)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=728)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=774)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=774)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=729)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=729)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=775)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=775)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=63208)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=63208)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=63208)
    at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
glyphops_init () at glyphops.c:296
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=731)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=731)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=808)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=808)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114104)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=<optimized out>) at sparse.c:161
161	    	p = spar_new_block(default_branch);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114104)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bff8 <diavar_sparp>) at sparse.c:157
157	    if(this->height ==  0) {
spar_new_block (fill_with=fill_with@entry=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=..., fill_with@entry=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_grow (this=0x806bff8 <diavar_sparp>) at sparse.c:163
163	    p[0] = this->root;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
163	    p[0] = this->root;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
164	    this->root.children = p;
167	    this->height += 1;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
170	    	| SPAR_STAGE_MASK;
167	    this->height += 1;
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114104)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bff8 <diavar_sparp>) at sparse.c:167
167	    this->height += 1;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114104)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
109		    	p->children = spar_new_block(default_branch);
spar_new_block (fill_with=fill_with@entry=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=..., fill_with@entry=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114104)
    at sparse.c:110
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
109		    	p->children = spar_new_block(default_branch);
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114104)
    at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114103)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114103)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114108)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114108)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=824)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=824)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=9711)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=9711)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=9711)
    at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=8413)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=8413)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=8413)
    at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114107)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114107)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=8407)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=8407)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
293	    	if(pd->spacing != 0) sparp_write(&diavar_sparp, pd->spacing, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114106)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114106)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:294
294	    	if(pd->combining != 0) sparp_write(&diavar_sparp, pd->combining, pd);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114105)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bff8 <diavar_sparp>, i=1114105)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
glyphops_init () at glyphops.c:295
295	    	if(pd->variant3 != 0) sparp_write(&diavar_sparp, pd->variant3, pd);
296	    	if(pd->variant4 != 0) sparp_write(&diavar_sparp, pd->variant4, pd);
292	    for(pd = diavars; pd->spacing != EOT; ++pd) {
299	}
main (argc=3, argv=0xbfffe864) at catdvi.c:237
237	    	outenc_init();
outenc_init () at outenc.c:1195
1195	{
1196	    assert(outenc_num < OE_TOOBIG);
1198	    pmesg(50, "BEGIN outenc_init\n");
pmesg (level=level@entry=50, 
    format=format@entry=0x805327f "BEGIN outenc_init\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
outenc_init () at outenc.c:1200
1200	    sparp_init(&accenting_sparp);
sparp_init (this=this@entry=0x806bf80 <accenting_sparp>) at sparse.c:177
177	void sparp_init(sparp_t * this) {
181	    spar_init(&this->p_spar, default_leaf);
spar_init (default_entry=..., this=this@entry=0x806bf80 <accenting_sparp>)
    at sparse.c:58
58	    this->height = 0;
59	    this->max_shift = - SPAR_BITS_PER_STAGE;
60	    this->max_index = 0;
61	    this->default_leaf = default_entry;
64	    this->root = default_entry;
outenc_init () at outenc.c:1201
1201	    vlist_init(&accenting_vlist);
vlist_init (this=this@entry=0x806bf64 <accenting_vlist>) at vlist.c:39
39	{
41	    this->rend_node.next = vlist_end(this);
40	    this->rend_node.prev = NULL;
41	    this->rend_node.next = vlist_end(this);
42	    this->rend_node.data = NULL;
44	    this->end_node.prev = vlist_rend(this);
45	    this->end_node.next = NULL;
46	    this->end_node.data = NULL;
48	    this->size = 0;
outenc_init () at outenc.c:1202
1202	    spars32_init(&glyphwidth_spars32, 1);
spars32_init (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    default_value=default_value@entry=1) at sparse.c:192
192	void spars32_init(spars32_t * this, sint32 default_value) {
196	    spar_init(&this->s32_spar, default_leaf);
spar_init (default_entry=..., this=this@entry=0x806bf38 <glyphwidth_spars32>)
    at sparse.c:58
58	    this->height = 0;
59	    this->max_shift = - SPAR_BITS_PER_STAGE;
60	    this->max_index = 0;
61	    this->default_leaf = default_entry;
64	    this->root = default_entry;
outenc_init () at outenc.c:1203
1203	    sparp_init(&glyphxlat_sparp);
sparp_init (this=this@entry=0x806bf24 <glyphxlat_sparp>) at sparse.c:177
177	void sparp_init(sparp_t * this) {
181	    spar_init(&this->p_spar, default_leaf);
spar_init (default_entry=..., this=this@entry=0x806bf24 <glyphxlat_sparp>)
    at sparse.c:58
58	    this->height = 0;
59	    this->max_shift = - SPAR_BITS_PER_STAGE;
60	    this->max_index = 0;
61	    this->default_leaf = default_entry;
64	    this->root = default_entry;
outenc_init () at outenc.c:1205
1205	    outenc_register_glyphtweaks(
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1316
1316	{
1321	    px = malloc(length * sizeof(linebuf_t));
1316	{
1321	    px = malloc(length * sizeof(linebuf_t));
1316	{
1321	    px = malloc(length * sizeof(linebuf_t));
1322	    if(px == NULL) enomem();
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074580, 
    garray0=0x8054850 <genx_CATDVI_DoubleS>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074580, 
    garray=garray@entry=0x8054850 <genx_CATDVI_DoubleS>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074580, 
    garray0=0x8054850 <genx_CATDVI_DoubleS>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114109) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=<optimized out>) at sparse.c:161
161	    	p = spar_new_block(default_branch);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114109) at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bf24 <glyphxlat_sparp>) at sparse.c:157
157	    if(this->height ==  0) {
158	    	p = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_grow (this=0x806bf24 <glyphxlat_sparp>) at sparse.c:163
163	    p[0] = this->root;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
163	    p[0] = this->root;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
164	    this->root.children = p;
167	    this->height += 1;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
170	    	| SPAR_STAGE_MASK;
167	    this->height += 1;
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114109) at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bf24 <glyphxlat_sparp>) at sparse.c:167
167	    this->height += 1;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114109) at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bf24 <glyphxlat_sparp>) at sparse.c:157
157	    if(this->height ==  0) {
spar_new_block (fill_with=fill_with@entry=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=..., fill_with@entry=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_grow (this=0x806bf24 <glyphxlat_sparp>) at sparse.c:163
163	    p[0] = this->root;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
163	    p[0] = this->root;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
164	    this->root.children = p;
167	    this->height += 1;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
170	    	| SPAR_STAGE_MASK;
167	    this->height += 1;
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114109) at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bf24 <glyphxlat_sparp>) at sparse.c:167
167	    this->height += 1;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114109) at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bf24 <glyphxlat_sparp>) at sparse.c:157
157	    if(this->height ==  0) {
spar_new_block (fill_with=fill_with@entry=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=..., fill_with@entry=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_grow (this=0x806bf24 <glyphxlat_sparp>) at sparse.c:163
163	    p[0] = this->root;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
163	    p[0] = this->root;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
164	    this->root.children = p;
167	    this->height += 1;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
170	    	| SPAR_STAGE_MASK;
167	    this->height += 1;
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114109) at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bf24 <glyphxlat_sparp>) at sparse.c:167
167	    this->height += 1;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114109) at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
109		    	p->children = spar_new_block(default_branch);
spar_new_block (fill_with=fill_with@entry=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=..., fill_with@entry=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114109) at sparse.c:110
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
109		    	p->children = spar_new_block(default_branch);
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114109) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114109) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=<optimized out>) at sparse.c:161
161	    	p = spar_new_block(default_branch);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114109) at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bf38 <glyphwidth_spars32>) at sparse.c:157
157	    if(this->height ==  0) {
158	    	p = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_grow (this=0x806bf38 <glyphwidth_spars32>) at sparse.c:163
163	    p[0] = this->root;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
163	    p[0] = this->root;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
164	    this->root.children = p;
167	    this->height += 1;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
170	    	| SPAR_STAGE_MASK;
167	    this->height += 1;
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114109) at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bf38 <glyphwidth_spars32>) at sparse.c:167
167	    this->height += 1;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114109) at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bf38 <glyphwidth_spars32>) at sparse.c:157
157	    if(this->height ==  0) {
spar_new_block (fill_with=fill_with@entry=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=..., fill_with@entry=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_grow (this=0x806bf38 <glyphwidth_spars32>) at sparse.c:163
163	    p[0] = this->root;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
163	    p[0] = this->root;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
164	    this->root.children = p;
167	    this->height += 1;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
170	    	| SPAR_STAGE_MASK;
167	    this->height += 1;
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114109) at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bf38 <glyphwidth_spars32>) at sparse.c:167
167	    this->height += 1;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114109) at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bf38 <glyphwidth_spars32>) at sparse.c:157
157	    if(this->height ==  0) {
spar_new_block (fill_with=fill_with@entry=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=..., fill_with@entry=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_grow (this=0x806bf38 <glyphwidth_spars32>) at sparse.c:163
163	    p[0] = this->root;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
163	    p[0] = this->root;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
164	    this->root.children = p;
167	    this->height += 1;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
170	    	| SPAR_STAGE_MASK;
167	    this->height += 1;
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114109) at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bf38 <glyphwidth_spars32>) at sparse.c:167
167	    this->height += 1;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114109) at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
109		    	p->children = spar_new_block(default_branch);
spar_new_block (fill_with=fill_with@entry=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=..., fill_with@entry=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114109) at sparse.c:110
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
109		    	p->children = spar_new_block(default_branch);
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114109) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807458c, 
    garray0=0x8054844 <genx_CATDVI_Ng>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807458c, 
    garray=garray@entry=0x8054844 <genx_CATDVI_Ng>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807458c, 
    garray0=0x8054844 <genx_CATDVI_Ng>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114111) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114111) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114111) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114111) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074598, 
    garray0=0x8054838 <genx_CATDVI_ng>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074598, 
    garray=garray@entry=0x8054838 <genx_CATDVI_ng>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074598, 
    garray0=0x8054838 <genx_CATDVI_ng>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114110) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114110) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114110) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114110) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80745a4, 
    garray0=0x8054830 <genx_CATDVI_negationslash>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80745a4, 
    garray=garray@entry=0x8054830 <genx_CATDVI_negationslash>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80745a4, 
    garray0=0x8054830 <genx_CATDVI_negationslash>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114108) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114108) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114108) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114108) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80745b0, 
    garray0=0x8054828 <genx_CATDVI_vector>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80745b0, 
    garray=garray@entry=0x8054828 <genx_CATDVI_vector>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80745b0, 
    garray0=0x8054828 <genx_CATDVI_vector>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114107) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114107) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114107) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114107) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80745bc, 
    garray0=0x8054820 <genx_ADOBE_zerooldstyle>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80745bc, 
    garray=garray@entry=0x8054820 <genx_ADOBE_zerooldstyle>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80745bc, 
    garray0=0x8054820 <genx_ADOBE_zerooldstyle>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63280) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63280) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63280) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63280) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63280) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63280) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80745c8, 
    garray0=0x8054818 <genx_ADOBE_oneoldstyle>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80745c8, 
    garray=garray@entry=0x8054818 <genx_ADOBE_oneoldstyle>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80745c8, 
    garray0=0x8054818 <genx_ADOBE_oneoldstyle>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63281) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63281) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63281) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63281) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80745d4, 
    garray0=0x8054810 <genx_ADOBE_twooldstyle>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80745d4, 
    garray=garray@entry=0x8054810 <genx_ADOBE_twooldstyle>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80745d4, 
    garray0=0x8054810 <genx_ADOBE_twooldstyle>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63282) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63282) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63282) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63282) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80745e0, 
    garray0=0x8054808 <genx_ADOBE_threeoldstyle>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80745e0, 
    garray=garray@entry=0x8054808 <genx_ADOBE_threeoldstyle>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80745e0, 
    garray0=0x8054808 <genx_ADOBE_threeoldstyle>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63283) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63283) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63283) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63283) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80745ec, 
    garray0=0x8054800 <genx_ADOBE_fouroldstyle>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80745ec, 
    garray=garray@entry=0x8054800 <genx_ADOBE_fouroldstyle>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80745ec, 
    garray0=0x8054800 <genx_ADOBE_fouroldstyle>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63284) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63284) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63284) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63284) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80745f8, 
    garray0=0x80547f8 <genx_ADOBE_fiveoldstyle>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80745f8, 
    garray=garray@entry=0x80547f8 <genx_ADOBE_fiveoldstyle>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80745f8, 
    garray0=0x80547f8 <genx_ADOBE_fiveoldstyle>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63285) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63285) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63285) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63285) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074604, 
    garray0=0x80547f0 <genx_ADOBE_sixoldstyle>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074604, 
    garray=garray@entry=0x80547f0 <genx_ADOBE_sixoldstyle>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074604, 
    garray0=0x80547f0 <genx_ADOBE_sixoldstyle>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63286) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63286) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63286) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63286) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074610, 
    garray0=0x80547e8 <genx_ADOBE_sevenoldstyle>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074610, 
    garray=garray@entry=0x80547e8 <genx_ADOBE_sevenoldstyle>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074610, 
    garray0=0x80547e8 <genx_ADOBE_sevenoldstyle>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63287) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63287) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63287) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63287) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807461c, 
    garray0=0x80547e0 <genx_ADOBE_eightoldstyle>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807461c, 
    garray=garray@entry=0x80547e0 <genx_ADOBE_eightoldstyle>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807461c, 
    garray0=0x80547e0 <genx_ADOBE_eightoldstyle>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63288) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63288) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63288) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63288) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074628, 
    garray0=0x80547d8 <genx_ADOBE_nineoldstyle>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074628, 
    garray=garray@entry=0x80547d8 <genx_ADOBE_nineoldstyle>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074628, 
    garray0=0x80547d8 <genx_ADOBE_nineoldstyle>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63289) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63289) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63289) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63289) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074634, 
    garray0=0x80547d0 <genx_ADOBE_dotlessj>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074634, 
    garray=garray@entry=0x80547d0 <genx_ADOBE_dotlessj>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074634, 
    garray0=0x80547d0 <genx_ADOBE_dotlessj>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63166) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63166) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=63166) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63166) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63166) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=63166) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074640, 
    garray0=0x80547c8 <genx_2parenleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074640, 
    garray=garray@entry=0x80547c8 <genx_2parenleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074640, 
    garray0=0x80547c8 <genx_2parenleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113856) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113856) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113856) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113856) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807464c, 
    garray0=0x80547c8 <genx_2parenleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807464c, 
    garray=garray@entry=0x80547c8 <genx_2parenleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807464c, 
    garray0=0x80547c8 <genx_2parenleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113872) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113872) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113872) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113872) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074658, 
    garray0=0x80547c8 <genx_2parenleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074658, 
    garray=garray@entry=0x80547c8 <genx_2parenleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074658, 
    garray0=0x80547c8 <genx_2parenleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113874) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113874) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113874) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113874) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074664, 
    garray0=0x80547c8 <genx_2parenleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074664, 
    garray=garray@entry=0x80547c8 <genx_2parenleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074664, 
    garray0=0x80547c8 <genx_2parenleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113888) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113888) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113888) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113888) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074670, 
    garray0=0x80547c0 <genx_2parenright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074670, 
    garray=garray@entry=0x80547c0 <genx_2parenright>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074670, 
    garray0=0x80547c0 <genx_2parenright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113857) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113857) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113857) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113857) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807467c, 
    garray0=0x80547c0 <genx_2parenright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807467c, 
    garray=garray@entry=0x80547c0 <genx_2parenright>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807467c, 
    garray0=0x80547c0 <genx_2parenright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113873) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113873) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113873) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113873) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074688, 
    garray0=0x80547c0 <genx_2parenright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074688, 
    garray=garray@entry=0x80547c0 <genx_2parenright>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074688, 
    garray0=0x80547c0 <genx_2parenright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113875) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113875) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113875) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113875) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074694, 
    garray0=0x80547c0 <genx_2parenright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074694, 
    garray=garray@entry=0x80547c0 <genx_2parenright>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074694, 
    garray0=0x80547c0 <genx_2parenright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113889) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113889) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113889) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113889) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80746a0, 
    garray0=0x80547b8 <genx_2bracketleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80746a0, 
    garray=garray@entry=0x80547b8 <genx_2bracketleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80746a0, 
    garray0=0x80547b8 <genx_2bracketleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113858) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113858) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113858) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113858) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80746ac, 
    garray0=0x80547b8 <genx_2bracketleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80746ac, 
    garray=garray@entry=0x80547b8 <genx_2bracketleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80746ac, 
    garray0=0x80547b8 <genx_2bracketleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113960) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113960) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113960) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113960) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80746b8, 
    garray0=0x80547b8 <genx_2bracketleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80746b8, 
    garray=garray@entry=0x80547b8 <genx_2bracketleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80746b8, 
    garray0=0x80547b8 <genx_2bracketleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113876) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113876) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113876) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113876) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80746c4, 
    garray0=0x80547b8 <genx_2bracketleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80746c4, 
    garray=garray@entry=0x80547b8 <genx_2bracketleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80746c4, 
    garray0=0x80547b8 <genx_2bracketleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113890) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113890) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113890) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113890) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80746d0, 
    garray0=0x80547b0 <genx_2bracketright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80746d0, 
    garray=garray@entry=0x80547b0 <genx_2bracketright>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80746d0, 
    garray0=0x80547b0 <genx_2bracketright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113859) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113859) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113859) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113859) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80746dc, 
    garray0=0x80547b0 <genx_2bracketright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80746dc, 
    garray=garray@entry=0x80547b0 <genx_2bracketright>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80746dc, 
    garray0=0x80547b0 <genx_2bracketright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113961) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113961) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113961) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113961) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80746e8, 
    garray0=0x80547b0 <genx_2bracketright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80746e8, 
    garray=garray@entry=0x80547b0 <genx_2bracketright>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80746e8, 
    garray0=0x80547b0 <genx_2bracketright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113877) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113877) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113877) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113877) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80746f4, 
    garray0=0x80547b0 <genx_2bracketright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80746f4, 
    garray=garray@entry=0x80547b0 <genx_2bracketright>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80746f4, 
    garray0=0x80547b0 <genx_2bracketright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113891) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113891) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113891) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113891) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074700, 
    garray0=0x80547a8 <genx_2braceleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074700, 
    garray=garray@entry=0x80547a8 <genx_2braceleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074700, 
    garray0=0x80547a8 <genx_2braceleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113864) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113864) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113864) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113864) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807470c, 
    garray0=0x80547a8 <genx_2braceleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807470c, 
    garray=garray@entry=0x80547a8 <genx_2braceleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807470c, 
    garray0=0x80547a8 <genx_2braceleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113966) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113966) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113966) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113966) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074718, 
    garray0=0x80547a8 <genx_2braceleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074718, 
    garray=garray@entry=0x80547a8 <genx_2braceleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074718, 
    garray0=0x80547a8 <genx_2braceleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113882) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113882) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113882) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113882) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074724, 
    garray0=0x80547a8 <genx_2braceleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074724, 
    garray=garray@entry=0x80547a8 <genx_2braceleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074724, 
    garray0=0x80547a8 <genx_2braceleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113896) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113896) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113896) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113896) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074730, 
    garray0=0x80547a0 <genx_2braceright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074730, 
    garray=garray@entry=0x80547a0 <genx_2braceright>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074730, 
    garray0=0x80547a0 <genx_2braceright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113865) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113865) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113865) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113865) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807473c, 
    garray0=0x80547a0 <genx_2braceright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807473c, 
    garray=garray@entry=0x80547a0 <genx_2braceright>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807473c, 
    garray0=0x80547a0 <genx_2braceright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113967) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113967) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113967) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113967) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074748, 
    garray0=0x80547a0 <genx_2braceright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074748, 
    garray=garray@entry=0x80547a0 <genx_2braceright>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074748, 
    garray0=0x80547a0 <genx_2braceright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113883) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113883) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113883) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113883) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074754, 
    garray0=0x80547a0 <genx_2braceright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074754, 
    garray=garray@entry=0x80547a0 <genx_2braceright>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074754, 
    garray0=0x80547a0 <genx_2braceright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113897) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113897) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113897) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113897) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074760, 
    garray0=0x8054798 <genx_2angleleftmath>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074760, 
    garray=garray@entry=0x8054798 <genx_2angleleftmath>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074760, 
    garray0=0x8054798 <genx_2angleleftmath>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113866) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113866) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113866) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113866) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807476c, 
    garray0=0x8054798 <genx_2angleleftmath>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807476c, 
    garray=garray@entry=0x8054798 <genx_2angleleftmath>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807476c, 
    garray0=0x8054798 <genx_2angleleftmath>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113924) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113924) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113924) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113924) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074778, 
    garray0=0x8054798 <genx_2angleleftmath>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074778, 
    garray=garray@entry=0x8054798 <genx_2angleleftmath>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074778, 
    garray0=0x8054798 <genx_2angleleftmath>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113884) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113884) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113884) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113884) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074784, 
    garray0=0x8054798 <genx_2angleleftmath>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074784, 
    garray=garray@entry=0x8054798 <genx_2angleleftmath>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074784, 
    garray0=0x8054798 <genx_2angleleftmath>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113898) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113898) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113898) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113898) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074790, 
    garray0=0x8054790 <genx_2anglerightmath>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074790, 
    garray=garray@entry=0x8054790 <genx_2anglerightmath>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074790, 
    garray0=0x8054790 <genx_2anglerightmath>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113867) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113867) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113867) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113867) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807479c, 
    garray0=0x8054790 <genx_2anglerightmath>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807479c, 
    garray=garray@entry=0x8054790 <genx_2anglerightmath>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807479c, 
    garray0=0x8054790 <genx_2anglerightmath>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113925) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113925) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113925) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113925) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80747a8, 
    garray0=0x8054790 <genx_2anglerightmath>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80747a8, 
    garray=garray@entry=0x8054790 <genx_2anglerightmath>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80747a8, 
    garray0=0x8054790 <genx_2anglerightmath>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113885) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113885) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113885) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113885) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80747b4, 
    garray0=0x8054790 <genx_2anglerightmath>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80747b4, 
    garray=garray@entry=0x8054790 <genx_2anglerightmath>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80747b4, 
    garray0=0x8054790 <genx_2anglerightmath>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113899) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113899) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113899) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113899) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80747c0, 
    garray0=0x8054788 <genx_2UNI_floorleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80747c0, 
    garray=garray@entry=0x8054788 <genx_2UNI_floorleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80747c0, 
    garray0=0x8054788 <genx_2UNI_floorleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113860) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113860) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113860) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113860) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80747cc, 
    garray0=0x8054788 <genx_2UNI_floorleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80747cc, 
    garray=garray@entry=0x8054788 <genx_2UNI_floorleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80747cc, 
    garray0=0x8054788 <genx_2UNI_floorleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113962) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113962) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113962) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113962) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80747d8, 
    garray0=0x8054788 <genx_2UNI_floorleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80747d8, 
    garray=garray@entry=0x8054788 <genx_2UNI_floorleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80747d8, 
    garray0=0x8054788 <genx_2UNI_floorleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113878) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113878) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113878) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113878) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80747e4, 
    garray0=0x8054788 <genx_2UNI_floorleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80747e4, 
    garray=garray@entry=0x8054788 <genx_2UNI_floorleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80747e4, 
    garray0=0x8054788 <genx_2UNI_floorleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113892) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113892) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113892) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113892) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80747f0, 
    garray0=0x8054780 <genx_2UNI_floorright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80747f0, 
    garray=garray@entry=0x8054780 <genx_2UNI_floorright>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80747f0, 
    garray0=0x8054780 <genx_2UNI_floorright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113861) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113861) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113861) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113861) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80747fc, 
    garray0=0x8054780 <genx_2UNI_floorright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80747fc, 
    garray=garray@entry=0x8054780 <genx_2UNI_floorright>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80747fc, 
    garray0=0x8054780 <genx_2UNI_floorright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113963) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113963) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113963) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113963) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074808, 
    garray0=0x8054780 <genx_2UNI_floorright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074808, 
    garray=garray@entry=0x8054780 <genx_2UNI_floorright>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074808, 
    garray0=0x8054780 <genx_2UNI_floorright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113879) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113879) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113879) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113879) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074814, 
    garray0=0x8054780 <genx_2UNI_floorright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074814, 
    garray=garray@entry=0x8054780 <genx_2UNI_floorright>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074814, 
    garray0=0x8054780 <genx_2UNI_floorright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113893) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113893) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113893) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113893) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074820, 
    garray0=0x8054778 <genx_2UNI_ceilingleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074820, 
    garray=garray@entry=0x8054778 <genx_2UNI_ceilingleft>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074820, 
    garray0=0x8054778 <genx_2UNI_ceilingleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113862) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113862) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113862) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113862) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807482c, 
    garray0=0x8054778 <genx_2UNI_ceilingleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807482c, 
    garray=garray@entry=0x8054778 <genx_2UNI_ceilingleft>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807482c, 
    garray0=0x8054778 <genx_2UNI_ceilingleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113964) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113964) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113964) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113964) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074838, 
    garray0=0x8054778 <genx_2UNI_ceilingleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074838, 
    garray=garray@entry=0x8054778 <genx_2UNI_ceilingleft>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074838, 
    garray0=0x8054778 <genx_2UNI_ceilingleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113880) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113880) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113880) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113880) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074844, 
    garray0=0x8054778 <genx_2UNI_ceilingleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074844, 
    garray=garray@entry=0x8054778 <genx_2UNI_ceilingleft>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074844, 
    garray0=0x8054778 <genx_2UNI_ceilingleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113894) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113894) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113894) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113894) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074850, 
    garray0=0x8054770 <genx_2UNI_ceilingright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074850, 
    garray=garray@entry=0x8054770 <genx_2UNI_ceilingright>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074850, 
    garray0=0x8054770 <genx_2UNI_ceilingright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113863) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113863) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113863) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113863) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807485c, 
    garray0=0x8054770 <genx_2UNI_ceilingright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807485c, 
    garray=garray@entry=0x8054770 <genx_2UNI_ceilingright>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807485c, 
    garray0=0x8054770 <genx_2UNI_ceilingright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113965) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113965) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113965) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113965) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074868, 
    garray0=0x8054770 <genx_2UNI_ceilingright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074868, 
    garray=garray@entry=0x8054770 <genx_2UNI_ceilingright>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074868, 
    garray0=0x8054770 <genx_2UNI_ceilingright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113881) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113881) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113881) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113881) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074874, 
    garray0=0x8054770 <genx_2UNI_ceilingright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074874, 
    garray=garray@entry=0x8054770 <genx_2UNI_ceilingright>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074874, 
    garray0=0x8054770 <genx_2UNI_ceilingright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113895) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113895) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113895) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113895) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074880, 
    garray0=0x8054768 <genx_2slash>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074880, 
    garray=garray@entry=0x8054768 <genx_2slash>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074880, 
    garray0=0x8054768 <genx_2slash>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113870) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113870) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113870) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113870) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807488c, 
    garray0=0x8054768 <genx_2slash>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807488c, 
    garray=garray@entry=0x8054768 <genx_2slash>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807488c, 
    garray0=0x8054768 <genx_2slash>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113902) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113902) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113902) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113902) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074898, 
    garray0=0x8054768 <genx_2slash>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074898, 
    garray=garray@entry=0x8054768 <genx_2slash>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074898, 
    garray0=0x8054768 <genx_2slash>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113886) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113886) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113886) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113886) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80748a4, 
    garray0=0x8054768 <genx_2slash>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80748a4, 
    garray=garray@entry=0x8054768 <genx_2slash>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80748a4, 
    garray0=0x8054768 <genx_2slash>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113900) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113900) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113900) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113900) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80748b0, 
    garray0=0x8054760 <genx_2backslash>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80748b0, 
    garray=garray@entry=0x8054760 <genx_2backslash>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80748b0, 
    garray0=0x8054760 <genx_2backslash>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113871) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113871) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113871) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113871) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80748bc, 
    garray0=0x8054760 <genx_2backslash>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80748bc, 
    garray=garray@entry=0x8054760 <genx_2backslash>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80748bc, 
    garray0=0x8054760 <genx_2backslash>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113903) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113903) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113903) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113903) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80748c8, 
    garray0=0x8054760 <genx_2backslash>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80748c8, 
    garray=garray@entry=0x8054760 <genx_2backslash>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80748c8, 
    garray0=0x8054760 <genx_2backslash>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113887) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113887) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113887) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113887) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80748d4, 
    garray0=0x8054760 <genx_2backslash>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80748d4, 
    garray=garray@entry=0x8054760 <genx_2backslash>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80748d4, 
    garray0=0x8054760 <genx_2backslash>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113901) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113901) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113901) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113901) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80748e0, 
    garray0=0x80546e8 <genx_2radical>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80748e0, 
    garray=garray@entry=0x80546e8 <genx_2radical>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80748e0, 
    garray0=0x80546e8 <genx_2radical>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113968) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113968) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113968) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113968) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80748ec, 
    garray0=0x80546e8 <genx_2radical>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80748ec, 
    garray=garray@entry=0x80546e8 <genx_2radical>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80748ec, 
    garray0=0x80546e8 <genx_2radical>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113969) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113969) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113969) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113969) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80748f8, 
    garray0=0x80546e8 <genx_2radical>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80748f8, 
    garray=garray@entry=0x80546e8 <genx_2radical>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80748f8, 
    garray0=0x80546e8 <genx_2radical>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113970) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113970) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113970) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113970) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074904, 
    garray0=0x80546e8 <genx_2radical>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074904, 
    garray=garray@entry=0x80546e8 <genx_2radical>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074904, 
    garray0=0x80546e8 <genx_2radical>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113971) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113971) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113971) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113971) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074910, 
    garray0=0x8054758 <genx_2integral>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074910, 
    garray=garray@entry=0x8054758 <genx_2integral>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074910, 
    garray0=0x8054758 <genx_2integral>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113938) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113938) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113938) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113938) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807491c, 
    garray0=0x8054758 <genx_2integral>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807491c, 
    garray=garray@entry=0x8054758 <genx_2integral>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807491c, 
    garray0=0x8054758 <genx_2integral>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113946) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113946) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113946) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113946) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074928, 
    garray0=0x8054750 <genx_2UNI_contintegral>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074928, 
    garray=garray@entry=0x8054750 <genx_2UNI_contintegral>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074928, 
    garray0=0x8054750 <genx_2UNI_contintegral>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113928) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113928) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113928) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113928) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074934, 
    garray0=0x8054750 <genx_2UNI_contintegral>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074934, 
    garray=garray@entry=0x8054750 <genx_2UNI_contintegral>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074934, 
    garray0=0x8054750 <genx_2UNI_contintegral>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113929) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113929) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113929) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113929) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074940, 
    garray0=0x8054748 <genx_2UNI_unionsq>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074940, 
    garray=garray@entry=0x8054748 <genx_2UNI_unionsq>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074940, 
    garray0=0x8054748 <genx_2UNI_unionsq>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113926) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113926) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113926) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113926) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807494c, 
    garray0=0x8054748 <genx_2UNI_unionsq>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807494c, 
    garray=garray@entry=0x8054748 <genx_2UNI_unionsq>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807494c, 
    garray0=0x8054748 <genx_2UNI_unionsq>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113927) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113927) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113927) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113927) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074958, 
    garray0=0x8054740 <genx_2UNI_circledot>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074958, 
    garray=garray@entry=0x8054740 <genx_2UNI_circledot>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074958, 
    garray0=0x8054740 <genx_2UNI_circledot>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113930) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113930) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113930) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113930) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074964, 
    garray0=0x8054740 <genx_2UNI_circledot>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074964, 
    garray=garray@entry=0x8054740 <genx_2UNI_circledot>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074964, 
    garray0=0x8054740 <genx_2UNI_circledot>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113931) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113931) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113931) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113931) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074970, 
    garray0=0x8054738 <genx_2circleplus>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074970, 
    garray=garray@entry=0x8054738 <genx_2circleplus>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074970, 
    garray0=0x8054738 <genx_2circleplus>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113932) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113932) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113932) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113932) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807497c, 
    garray0=0x8054738 <genx_2circleplus>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807497c, 
    garray=garray@entry=0x8054738 <genx_2circleplus>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807497c, 
    garray0=0x8054738 <genx_2circleplus>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113933) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113933) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113933) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113933) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074988, 
    garray0=0x8054730 <genx_2circlemultiply>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074988, 
    garray=garray@entry=0x8054730 <genx_2circlemultiply>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074988, 
    garray0=0x8054730 <genx_2circlemultiply>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113934) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113934) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113934) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113934) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074994, 
    garray0=0x8054730 <genx_2circlemultiply>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074994, 
    garray=garray@entry=0x8054730 <genx_2circlemultiply>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074994, 
    garray0=0x8054730 <genx_2circlemultiply>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113935) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113935) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113935) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113935) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80749a0, 
    garray0=0x8054728 <genx_2summation>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80749a0, 
    garray=garray@entry=0x8054728 <genx_2summation>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80749a0, 
    garray0=0x8054728 <genx_2summation>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113936) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113936) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113936) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113936) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80749ac, 
    garray0=0x8054728 <genx_2summation>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80749ac, 
    garray=garray@entry=0x8054728 <genx_2summation>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80749ac, 
    garray0=0x8054728 <genx_2summation>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113944) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113944) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113944) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113944) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80749b8, 
    garray0=0x8054720 <genx_2product>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80749b8, 
    garray=garray@entry=0x8054720 <genx_2product>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80749b8, 
    garray0=0x8054720 <genx_2product>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113937) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113937) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113937) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113937) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80749c4, 
    garray0=0x8054720 <genx_2product>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80749c4, 
    garray=garray@entry=0x8054720 <genx_2product>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80749c4, 
    garray0=0x8054720 <genx_2product>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113945) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113945) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113945) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113945) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80749d0, 
    garray0=0x8054710 <genx_2union>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80749d0, 
    garray=garray@entry=0x8054710 <genx_2union>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80749d0, 
    garray0=0x8054710 <genx_2union>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113939) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113939) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113939) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113939) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80749dc, 
    garray0=0x8054710 <genx_2union>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80749dc, 
    garray=garray@entry=0x8054710 <genx_2union>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80749dc, 
    garray0=0x8054710 <genx_2union>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113947) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113947) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113947) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113947) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80749e8, 
    garray0=0x8054708 <genx_2intersection>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80749e8, 
    garray=garray@entry=0x8054708 <genx_2intersection>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80749e8, 
    garray0=0x8054708 <genx_2intersection>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113940) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113940) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113940) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113940) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80749f4, 
    garray0=0x8054708 <genx_2intersection>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80749f4, 
    garray=garray@entry=0x8054708 <genx_2intersection>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80749f4, 
    garray0=0x8054708 <genx_2intersection>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113948) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113948) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113948) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113948) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074a00, 
    garray0=0x8054700 <genx_2UNI_unionmulti>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074a00, 
    garray=garray@entry=0x8054700 <genx_2UNI_unionmulti>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074a00, 
    garray0=0x8054700 <genx_2UNI_unionmulti>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113941) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113941) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113941) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113941) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074a0c, 
    garray0=0x8054700 <genx_2UNI_unionmulti>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074a0c, 
    garray=garray@entry=0x8054700 <genx_2UNI_unionmulti>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074a0c, 
    garray0=0x8054700 <genx_2UNI_unionmulti>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113949) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113949) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113949) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113949) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074a18, 
    garray0=0x80546f8 <genx_2logicaland>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074a18, 
    garray=garray@entry=0x80546f8 <genx_2logicaland>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074a18, 
    garray0=0x80546f8 <genx_2logicaland>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113942) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113942) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113942) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113942) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074a24, 
    garray0=0x80546f8 <genx_2logicaland>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074a24, 
    garray=garray@entry=0x80546f8 <genx_2logicaland>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074a24, 
    garray0=0x80546f8 <genx_2logicaland>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113950) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113950) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113950) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113950) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074a30, 
    garray0=0x80546f0 <genx_2logicalor>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074a30, 
    garray=garray@entry=0x80546f0 <genx_2logicalor>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074a30, 
    garray0=0x80546f0 <genx_2logicalor>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113943) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113943) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113943) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113943) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074a3c, 
    garray0=0x80546f0 <genx_2logicalor>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074a3c, 
    garray=garray@entry=0x80546f0 <genx_2logicalor>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074a3c, 
    garray0=0x80546f0 <genx_2logicalor>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113951) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113951) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113951) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113951) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074a48, 
    garray0=0x8054720 <genx_2product>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074a48, 
    garray=garray@entry=0x8054720 <genx_2product>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074a48, 
    garray0=0x8054720 <genx_2product>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113937) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113937) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113937) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113937) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074a54, 
    garray0=0x8054720 <genx_2product>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074a54, 
    garray=garray@entry=0x8054720 <genx_2product>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074a54, 
    garray0=0x8054720 <genx_2product>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113945) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113945) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113945) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113945) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074a60, 
    garray0=0x8054718 <genx_2UNI_coproduct>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074a60, 
    garray=garray@entry=0x8054718 <genx_2UNI_coproduct>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074a60, 
    garray0=0x8054718 <genx_2UNI_coproduct>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113952) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113952) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113952) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113952) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074a6c, 
    garray0=0x8054718 <genx_2UNI_coproduct>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074a6c, 
    garray=garray@entry=0x8054718 <genx_2UNI_coproduct>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074a6c, 
    garray0=0x8054718 <genx_2UNI_coproduct>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113953) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113953) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113953) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113953) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074a78, 
    garray0=0x80546e0 <genx_2asciicircum>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074a78, 
    garray=garray@entry=0x80546e0 <genx_2asciicircum>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074a78, 
    garray0=0x80546e0 <genx_2asciicircum>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113954) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113954) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113954) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113954) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074a84, 
    garray0=0x80546e0 <genx_2asciicircum>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074a84, 
    garray=garray@entry=0x80546e0 <genx_2asciicircum>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074a84, 
    garray0=0x80546e0 <genx_2asciicircum>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113955) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113955) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113955) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113955) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074a90, 
    garray0=0x80546e0 <genx_2asciicircum>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074a90, 
    garray=garray@entry=0x80546e0 <genx_2asciicircum>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074a90, 
    garray0=0x80546e0 <genx_2asciicircum>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113956) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113956) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113956) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113956) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074a9c, 
    garray0=0x80546d8 <genx_2asciitilde>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074a9c, 
    garray=garray@entry=0x80546d8 <genx_2asciitilde>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074a9c, 
    garray0=0x80546d8 <genx_2asciitilde>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113957) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113957) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113957) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113957) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074aa8, 
    garray0=0x80546d8 <genx_2asciitilde>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074aa8, 
    garray=garray@entry=0x80546d8 <genx_2asciitilde>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074aa8, 
    garray0=0x80546d8 <genx_2asciitilde>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113958) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113958) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113958) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113958) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074ab4, 
    garray0=0x80546d8 <genx_2asciitilde>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074ab4, 
    garray=garray@entry=0x80546d8 <genx_2asciitilde>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074ab4, 
    garray0=0x80546d8 <genx_2asciitilde>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113959) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1113959) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113959) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1113959) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074ac0, 
    garray0=0x80546e0 <genx_2asciicircum>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074ac0, 
    garray=garray@entry=0x80546e0 <genx_2asciicircum>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074ac0, 
    garray0=0x80546e0 <genx_2asciicircum>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114095) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114095) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114095) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114095) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8074acc, 
    garray0=0x80546d8 <genx_2asciitilde>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8074acc, 
    garray=garray@entry=0x80546d8 <genx_2asciitilde>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8074acc, 
    garray0=0x80546d8 <genx_2asciitilde>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114096) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=1114096) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114096) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=1114096) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (
    tweaks=tweaks@entry=0x8054180 <generic_glyphtweaks>, 
    length=length@entry=114) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1343	}
outenc_init () at outenc.c:1211
1211	    generic_register_accentings(generic_accentings);
generic_register_accentings (pa=pa@entry=0x805efa0 <generic_accentings>)
    at outenc.c:326
326	{
334	    for( ; pa->base != 0; ++pa) {
337	        old_va = sparp_read(&accenting_sparp, pa->base);
spar_const_entry (this=this@entry=0x806bf80 <accenting_sparp>, i=67)
    at sparse.c:79
79	{
83	    if(i > this->max_index) return &(this->default_leaf);
92	}
generic_register_accentings (pa=pa@entry=0x805efa0 <generic_accentings>)
    at outenc.c:340
340		new_va = vlist_insert_before(&accenting_vlist, old_va, pa);
338		if(old_va == NULL) old_va = vlist_begin(&accenting_vlist);
334	    for( ; pa->base != 0; ++pa) {
340		new_va = vlist_insert_before(&accenting_vlist, old_va, pa);
vlist_insert_before (this=this@entry=0x806bf64 <accenting_vlist>, 
    where=0x806bf70 <accenting_vlist+12>, 
    newdata=newdata@entry=0x805efa0 <generic_accentings>) at vlist.c:88
88	{
91	    assert(where != vlist_rend(this));
92	    prev = where->prev;
94	    newnode = malloc(sizeof(vlist_node_t));
95	    if(newnode == NULL) enomem();
99	    newnode->data = (void *) newdata; /* de-const is intentional */
97	    newnode->prev = prev;
98	    newnode->next = where;
99	    newnode->data = (void *) newdata; /* de-const is intentional */
101	    prev->next = newnode;
102	    where->prev = newnode;
104	    this->size += 1;
106	}
generic_register_accentings (pa=pa@entry=0x805efa0 <generic_accentings>)
    at outenc.c:341
341		sparp_write(&accenting_sparp, pa->base, new_va);
340		new_va = vlist_insert_before(&accenting_vlist, old_va, pa);
341		sparp_write(&accenting_sparp, pa->base, new_va);
spar_assignable_entry (this=this@entry=0x806bf80 <accenting_sparp>, i=67)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=<optimized out>) at sparse.c:161
161	    	p = spar_new_block(default_branch);
spar_assignable_entry (this=this@entry=0x806bf80 <accenting_sparp>, i=67)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bf80 <accenting_sparp>) at sparse.c:157
157	    if(this->height ==  0) {
158	    	p = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_grow (this=0x806bf80 <accenting_sparp>) at sparse.c:163
163	    p[0] = this->root;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
163	    p[0] = this->root;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
164	    this->root.children = p;
167	    this->height += 1;
168	    this->max_shift += SPAR_BITS_PER_STAGE;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
170	    	| SPAR_STAGE_MASK;
167	    this->height += 1;
spar_assignable_entry (this=this@entry=0x806bf80 <accenting_sparp>, i=67)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
spar_grow (this=0x806bf80 <accenting_sparp>) at sparse.c:167
167	    this->height += 1;
169	    this->max_index = (this->max_index << SPAR_BITS_PER_STAGE)
spar_assignable_entry (this=this@entry=0x806bf80 <accenting_sparp>, i=67)
    at sparse.c:100
100	    while(i > this->max_index) spar_grow(this);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
generic_register_accentings (pa=0x805efac <generic_accentings+12>, 
    pa@entry=0x805efa0 <generic_accentings>) at outenc.c:334
334	    for( ; pa->base != 0; ++pa) {
337	        old_va = sparp_read(&accenting_sparp, pa->base);
spar_const_entry (this=this@entry=0x806bf80 <accenting_sparp>, i=76)
    at sparse.c:79
79	{
83	    if(i > this->max_index) return &(this->default_leaf);
86	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
85	    p = &(this->root);
86	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
87	    	if(p->children == NULL) return &(this->default_leaf);
88		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
86	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
88		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
86	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
92	}
generic_register_accentings (pa=0x805efac <generic_accentings+12>, 
    pa@entry=0x805efa0 <generic_accentings>) at outenc.c:340
340		new_va = vlist_insert_before(&accenting_vlist, old_va, pa);
338		if(old_va == NULL) old_va = vlist_begin(&accenting_vlist);
334	    for( ; pa->base != 0; ++pa) {
340		new_va = vlist_insert_before(&accenting_vlist, old_va, pa);
vlist_insert_before (this=this@entry=0x806bf64 <accenting_vlist>, 
    where=0x80789d0, newdata=newdata@entry=0x805efac <generic_accentings+12>)
    at vlist.c:88
88	{
91	    assert(where != vlist_rend(this));
92	    prev = where->prev;
94	    newnode = malloc(sizeof(vlist_node_t));
95	    if(newnode == NULL) enomem();
99	    newnode->data = (void *) newdata; /* de-const is intentional */
97	    newnode->prev = prev;
98	    newnode->next = where;
99	    newnode->data = (void *) newdata; /* de-const is intentional */
101	    prev->next = newnode;
102	    where->prev = newnode;
104	    this->size += 1;
106	}
generic_register_accentings (pa=0x805efac <generic_accentings+12>, 
    pa@entry=0x805efa0 <generic_accentings>) at outenc.c:341
341		sparp_write(&accenting_sparp, pa->base, new_va);
340		new_va = vlist_insert_before(&accenting_vlist, old_va, pa);
341		sparp_write(&accenting_sparp, pa->base, new_va);
spar_assignable_entry (this=this@entry=0x806bf80 <accenting_sparp>, i=76)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf80 <accenting_sparp>, i=76)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
generic_register_accentings (pa=0x805efb8 <generic_accentings+24>, 
    pa@entry=0x805efa0 <generic_accentings>) at outenc.c:334
334	    for( ; pa->base != 0; ++pa) {
337	        old_va = sparp_read(&accenting_sparp, pa->base);
spar_const_entry (this=this@entry=0x806bf80 <accenting_sparp>, i=108)
    at sparse.c:79
79	{
83	    if(i > this->max_index) return &(this->default_leaf);
86	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
85	    p = &(this->root);
86	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
87	    	if(p->children == NULL) return &(this->default_leaf);
88		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
86	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
88		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
86	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
92	}
generic_register_accentings (pa=0x805efb8 <generic_accentings+24>, 
    pa@entry=0x805efa0 <generic_accentings>) at outenc.c:340
340		new_va = vlist_insert_before(&accenting_vlist, old_va, pa);
338		if(old_va == NULL) old_va = vlist_begin(&accenting_vlist);
334	    for( ; pa->base != 0; ++pa) {
340		new_va = vlist_insert_before(&accenting_vlist, old_va, pa);
vlist_insert_before (this=this@entry=0x806bf64 <accenting_vlist>, 
    where=0x8078de8, newdata=newdata@entry=0x805efb8 <generic_accentings+24>)
    at vlist.c:88
88	{
91	    assert(where != vlist_rend(this));
92	    prev = where->prev;
94	    newnode = malloc(sizeof(vlist_node_t));
95	    if(newnode == NULL) enomem();
99	    newnode->data = (void *) newdata; /* de-const is intentional */
97	    newnode->prev = prev;
98	    newnode->next = where;
99	    newnode->data = (void *) newdata; /* de-const is intentional */
101	    prev->next = newnode;
102	    where->prev = newnode;
104	    this->size += 1;
106	}
generic_register_accentings (pa=0x805efb8 <generic_accentings+24>, 
    pa@entry=0x805efa0 <generic_accentings>) at outenc.c:341
341		sparp_write(&accenting_sparp, pa->base, new_va);
340		new_va = vlist_insert_before(&accenting_vlist, old_va, pa);
341		sparp_write(&accenting_sparp, pa->base, new_va);
spar_assignable_entry (this=this@entry=0x806bf80 <accenting_sparp>, i=108)
    at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf80 <accenting_sparp>, i=108)
    at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
generic_register_accentings (pa=0x805efc4 <generic_accentings+36>, 
    pa@entry=0x805efa0 <generic_accentings>) at outenc.c:334
334	    for( ; pa->base != 0; ++pa) {
344	}
outenc_init () at outenc.c:1214
1214	    switch(outenc_num) {
1219		    ascii_init();
ascii_init () at outenc.c:952
952	    outenc_register_glyphtweaks(
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1316
1316	{
1321	    px = malloc(length * sizeof(linebuf_t));
1316	{
1321	    px = malloc(length * sizeof(linebuf_t));
1316	{
1321	    px = malloc(length * sizeof(linebuf_t));
1322	    if(px == NULL) enomem();
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078e08, garray0=0x8053f54 <a2l1x_IJ>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078e08, 
    garray=garray@entry=0x8053f54 <a2l1x_IJ>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078e08, garray0=0x8053f54 <a2l1x_IJ>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=306) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=306) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=306) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=306) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=306) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=306) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078e14, garray0=0x8053f48 <a2l1x_ij>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078e14, 
    garray=garray@entry=0x8053f48 <a2l1x_ij>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078e14, garray0=0x8053f48 <a2l1x_ij>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=307) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=307) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=307) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=307) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078e20, garray0=0x8053f3c <a2l1x_OE>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078e20, 
    garray=garray@entry=0x8053f3c <a2l1x_OE>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078e20, garray0=0x8053f3c <a2l1x_OE>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=338) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=338) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=338) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=338) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078e2c, garray0=0x8053f30 <a2l1x_oe>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078e2c, 
    garray=garray@entry=0x8053f30 <a2l1x_oe>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078e2c, garray0=0x8053f30 <a2l1x_oe>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=339) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=339) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=339) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=339) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078e38, garray0=0x8053f24 <a2l1x_Eng>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078e38, 
    garray=garray@entry=0x8053f24 <a2l1x_Eng>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078e38, garray0=0x8053f24 <a2l1x_Eng>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=330) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=330) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=330) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=330) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078e44, garray0=0x8053f18 <a2l1x_eng>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078e44, 
    garray=garray@entry=0x8053f18 <a2l1x_eng>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078e44, garray0=0x8053f18 <a2l1x_eng>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=331) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=331) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=331) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=331) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078e50, 
    garray0=0x8053f0c <a2l1x_endash>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078e50, 
    garray=garray@entry=0x8053f0c <a2l1x_endash>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078e50, 
    garray0=0x8053f0c <a2l1x_endash>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8211) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8211) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8211) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8211) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8211) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8211) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078e5c, 
    garray0=0x8053efc <a2l1x_emdash>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078e5c, 
    garray=garray@entry=0x8053efc <a2l1x_emdash>, len=3) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078e5c, 
    garray0=0x8053efc <a2l1x_emdash>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8212) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8212) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8212) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8212) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078e68, 
    garray0=0x8053ef4 <a2l1x_quoteleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078e68, 
    garray=garray@entry=0x8053ef4 <a2l1x_quoteleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078e68, 
    garray0=0x8053ef4 <a2l1x_quoteleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8216) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8216) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8216) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8216) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078e74, 
    garray0=0x8053eec <a2l1x_quoteright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078e74, 
    garray=garray@entry=0x8053eec <a2l1x_quoteright>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078e74, 
    garray0=0x8053eec <a2l1x_quoteright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8217) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8217) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8217) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8217) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078e80, 
    garray0=0x8053ee4 <a2l1x_quotereversed>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078e80, 
    garray=garray@entry=0x8053ee4 <a2l1x_quotereversed>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078e80, 
    garray0=0x8053ee4 <a2l1x_quotereversed>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8219) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8219) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8219) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8219) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078e8c, 
    garray0=0x8053edc <a2l1x_quotedblleft>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078e8c, 
    garray=garray@entry=0x8053edc <a2l1x_quotedblleft>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078e8c, 
    garray0=0x8053edc <a2l1x_quotedblleft>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8220) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8220) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8220) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8220) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078e98, 
    garray0=0x8053ed4 <a2l1x_quotedblright>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078e98, 
    garray=garray@entry=0x8053ed4 <a2l1x_quotedblright>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078e98, 
    garray0=0x8053ed4 <a2l1x_quotedblright>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8221) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8221) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8221) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8221) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078ea4, 
    garray0=0x8053ecc <a2l1x_UNI_quotedblreversed>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078ea4, 
    garray=garray@entry=0x8053ecc <a2l1x_UNI_quotedblreversed>, len=1)
    at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078ea4, 
    garray0=0x8053ecc <a2l1x_UNI_quotedblreversed>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8223) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8223) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8223) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8223) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078eb0, garray0=0x8053ec0 <a2l1x_ff>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078eb0, 
    garray=garray@entry=0x8053ec0 <a2l1x_ff>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078eb0, garray0=0x8053ec0 <a2l1x_ff>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=64256) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=64256) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=64256) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=64256) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=64256) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=64256) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078ebc, garray0=0x8053eb4 <a2l1x_fi>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078ebc, 
    garray=garray@entry=0x8053eb4 <a2l1x_fi>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078ebc, garray0=0x8053eb4 <a2l1x_fi>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=64257) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=64257) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=64257) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=64257) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078ec8, garray0=0x8053ea8 <a2l1x_fl>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078ec8, 
    garray=garray@entry=0x8053ea8 <a2l1x_fl>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078ec8, garray0=0x8053ea8 <a2l1x_fl>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=64258) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=64258) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=64258) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=64258) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078ed4, garray0=0x8053e98 <a2l1x_ffi>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078ed4, 
    garray=garray@entry=0x8053e98 <a2l1x_ffi>, len=3) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078ed4, garray0=0x8053e98 <a2l1x_ffi>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=64259) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=64259) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=64259) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=64259) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078ee0, garray0=0x8053e88 <a2l1x_ffl>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078ee0, 
    garray=garray@entry=0x8053e88 <a2l1x_ffl>, len=3) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078ee0, garray0=0x8053e88 <a2l1x_ffl>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=64260) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=64260) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=64260) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=64260) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078eec, 
    garray0=0x8053e7c <a2l1x_UNI_st>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078eec, 
    garray=garray@entry=0x8053e7c <a2l1x_UNI_st>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078eec, 
    garray0=0x8053e7c <a2l1x_UNI_st>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=64262) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=64262) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=64262) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=64262) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078ef8, 
    garray0=0x8053e70 <a2l1x_UNI_longst>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078ef8, 
    garray=garray@entry=0x8053e70 <a2l1x_UNI_longst>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078ef8, 
    garray0=0x8053e70 <a2l1x_UNI_longst>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=64261) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=64261) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=64261) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=64261) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078f04, 
    garray0=0x8053e68 <a2l1x_minus>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078f04, 
    garray=garray@entry=0x8053e68 <a2l1x_minus>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078f04, 
    garray0=0x8053e68 <a2l1x_minus>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8722) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8722) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8722) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8722) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8722) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8722) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078f10, 
    garray0=0x8053e60 <a2l1x_asteriskmath>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078f10, 
    garray=garray@entry=0x8053e60 <a2l1x_asteriskmath>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078f10, 
    garray0=0x8053e60 <a2l1x_asteriskmath>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8727) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8727) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8727) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8727) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078f1c, 
    garray0=0x8053e5c <a2l1x_2emptystring>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078f1c, 
    garray=garray@entry=0x8053e5c <a2l1x_2emptystring>, len=0) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078f1c, 
    garray0=0x8053e5c <a2l1x_2emptystring>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8204) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8204) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8204) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8204) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078f28, 
    garray0=0x8053e54 <a2l1x_2asciitilde>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078f28, 
    garray=garray@entry=0x8053e54 <a2l1x_2asciitilde>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078f28, 
    garray0=0x8053e54 <a2l1x_2asciitilde>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=732) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=732) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=732) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=732) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=732) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=732) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078f34, 
    garray0=0x8053e54 <a2l1x_2asciitilde>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078f34, 
    garray=garray@entry=0x8053e54 <a2l1x_2asciitilde>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078f34, 
    garray0=0x8053e54 <a2l1x_2asciitilde>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8764) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8764) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8764) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8764) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078f40, 
    garray0=0x8053e48 <a2l1x_lessequal>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078f40, 
    garray=garray@entry=0x8053e48 <a2l1x_lessequal>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078f40, 
    garray0=0x8053e48 <a2l1x_lessequal>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8804) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8804) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8804) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8804) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078f4c, 
    garray0=0x8053e3c <a2l1x_greaterequal>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078f4c, 
    garray=garray@entry=0x8053e3c <a2l1x_greaterequal>, len=2) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078f4c, 
    garray0=0x8053e3c <a2l1x_greaterequal>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8805) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8805) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8805) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8805) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078f58, garray0=0x8053e34 <a2l1x_2A>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078f58, 
    garray=garray@entry=0x8053e34 <a2l1x_2A>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078f58, garray0=0x8053e34 <a2l1x_2A>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119964) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119964) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
109		    	p->children = spar_new_block(default_branch);
spar_new_block (fill_with=fill_with@entry=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=..., fill_with@entry=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119964) at sparse.c:110
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
109		    	p->children = spar_new_block(default_branch);
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119964) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119964) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119964) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
109		    	p->children = spar_new_block(default_branch);
spar_new_block (fill_with=fill_with@entry=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=..., fill_with@entry=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119964) at sparse.c:110
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
109		    	p->children = spar_new_block(default_branch);
110		    	p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119964) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078f64, garray0=0x8053e2c <a2l1x_2>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078f64, 
    garray=garray@entry=0x8053e2c <a2l1x_2>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078f64, garray0=0x8053e2c <a2l1x_2>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8492) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8492) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8492) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8492) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8492) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8492) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078f70, garray0=0x8053e24 <a2l1x_2C>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078f70, 
    garray=garray@entry=0x8053e24 <a2l1x_2C>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078f70, garray0=0x8053e24 <a2l1x_2C>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119966) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119966) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119966) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119966) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078f7c, garray0=0x8053e1c <a2l1x_2D>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078f7c, 
    garray=garray@entry=0x8053e1c <a2l1x_2D>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078f7c, garray0=0x8053e1c <a2l1x_2D>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119967) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119967) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119967) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119967) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078f88, garray0=0x8053e14 <a2l1x_2E>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078f88, 
    garray=garray@entry=0x8053e14 <a2l1x_2E>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078f88, garray0=0x8053e14 <a2l1x_2E>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8496) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8496) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8496) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8496) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078f94, garray0=0x8053e0c <a2l1x_2F>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078f94, 
    garray=garray@entry=0x8053e0c <a2l1x_2F>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078f94, garray0=0x8053e0c <a2l1x_2F>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8497) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8497) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8497) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8497) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078fa0, garray0=0x8053e04 <a2l1x_2G>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078fa0, 
    garray=garray@entry=0x8053e04 <a2l1x_2G>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078fa0, garray0=0x8053e04 <a2l1x_2G>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119970) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119970) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119970) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119970) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078fac, garray0=0x8053dfc <a2l1x_2H>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078fac, 
    garray=garray@entry=0x8053dfc <a2l1x_2H>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078fac, garray0=0x8053dfc <a2l1x_2H>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8459) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8459) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8459) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8459) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078fb8, garray0=0x8053df4 <a2l1x_2I>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078fb8, 
    garray=garray@entry=0x8053df4 <a2l1x_2I>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078fb8, garray0=0x8053df4 <a2l1x_2I>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8464) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8464) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8464) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8464) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078fc4, garray0=0x8053dec <a2l1x_2J>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078fc4, 
    garray=garray@entry=0x8053dec <a2l1x_2J>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078fc4, garray0=0x8053dec <a2l1x_2J>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119973) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119973) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119973) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119973) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078fd0, garray0=0x8053de4 <a2l1x_2K>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078fd0, 
    garray=garray@entry=0x8053de4 <a2l1x_2K>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078fd0, garray0=0x8053de4 <a2l1x_2K>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119974) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119974) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119974) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119974) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078fdc, garray0=0x8053ddc <a2l1x_2L>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078fdc, 
    garray=garray@entry=0x8053ddc <a2l1x_2L>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078fdc, garray0=0x8053ddc <a2l1x_2L>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8466) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8466) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8466) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8466) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078fe8, garray0=0x8053dd4 <a2l1x_2M>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078fe8, 
    garray=garray@entry=0x8053dd4 <a2l1x_2M>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078fe8, garray0=0x8053dd4 <a2l1x_2M>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8499) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8499) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8499) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8499) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8078ff4, garray0=0x8053dcc <a2l1x_2>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8078ff4, 
    garray=garray@entry=0x8053dcc <a2l1x_2>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8078ff4, garray0=0x8053dcc <a2l1x_2>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119977) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119977) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119977) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119977) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079000, garray0=0x8053dc4 <a2l1x_2O>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079000, 
    garray=garray@entry=0x8053dc4 <a2l1x_2O>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079000, garray0=0x8053dc4 <a2l1x_2O>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119978) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119978) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119978) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119978) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807900c, garray0=0x8053dbc <a2l1x_2P>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807900c, 
    garray=garray@entry=0x8053dbc <a2l1x_2P>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807900c, garray0=0x8053dbc <a2l1x_2P>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119979) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119979) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119979) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119979) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079018, garray0=0x8053db4 <a2l1x_2Q>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079018, 
    garray=garray@entry=0x8053db4 <a2l1x_2Q>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079018, garray0=0x8053db4 <a2l1x_2Q>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119980) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119980) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119980) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119980) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079024, garray0=0x8053dac <a2l1x_2R>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079024, 
    garray=garray@entry=0x8053dac <a2l1x_2R>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079024, garray0=0x8053dac <a2l1x_2R>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8475) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8475) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8475) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8475) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079030, garray0=0x8053da4 <a2l1x_2S>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079030, 
    garray=garray@entry=0x8053da4 <a2l1x_2S>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079030, garray0=0x8053da4 <a2l1x_2S>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119982) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119982) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119982) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119982) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807903c, garray0=0x8053d9c <a2l1x_2T>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807903c, 
    garray=garray@entry=0x8053d9c <a2l1x_2T>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807903c, garray0=0x8053d9c <a2l1x_2T>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119983) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119983) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119983) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119983) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079048, garray0=0x8053d94 <a2l1x_2U>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079048, 
    garray=garray@entry=0x8053d94 <a2l1x_2U>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079048, garray0=0x8053d94 <a2l1x_2U>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119984) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119984) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119984) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119984) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079054, garray0=0x8053d8c <a2l1x_2V>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079054, 
    garray=garray@entry=0x8053d8c <a2l1x_2V>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079054, garray0=0x8053d8c <a2l1x_2V>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119985) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119985) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119985) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119985) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079060, garray0=0x8053d84 <a2l1x_2W>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079060, 
    garray=garray@entry=0x8053d84 <a2l1x_2W>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079060, garray0=0x8053d84 <a2l1x_2W>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119986) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119986) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119986) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119986) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807906c, garray0=0x8053d7c <a2l1x_2>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807906c, 
    garray=garray@entry=0x8053d7c <a2l1x_2>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807906c, garray0=0x8053d7c <a2l1x_2>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119987) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119987) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119987) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119987) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079078, garray0=0x8053d74 <a2l1x_2Y>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079078, 
    garray=garray@entry=0x8053d74 <a2l1x_2Y>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079078, garray0=0x8053d74 <a2l1x_2Y>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119988) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119988) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119988) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119988) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079084, garray0=0x8053d6c <a2l1x_2Z>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079084, 
    garray=garray@entry=0x8053d6c <a2l1x_2Z>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079084, garray0=0x8053d6c <a2l1x_2Z>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119989) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=119989) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119989) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=119989) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079090, garray0=0x8053d0c <a2l1x_2l>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079090, 
    garray=garray@entry=0x8053d0c <a2l1x_2l>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079090, garray0=0x8053d0c <a2l1x_2l>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8467) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8467) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8467) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8467) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807909c, garray0=0x8053e34 <a2l1x_2A>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807909c, 
    garray=garray@entry=0x8053e34 <a2l1x_2A>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807909c, garray0=0x8053e34 <a2l1x_2A>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120120) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120120) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120120) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120120) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120120) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120120) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80790a8, garray0=0x8053e2c <a2l1x_2>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80790a8, 
    garray=garray@entry=0x8053e2c <a2l1x_2>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80790a8, garray0=0x8053e2c <a2l1x_2>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120121) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120121) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120121) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120121) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80790b4, garray0=0x8053e24 <a2l1x_2C>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80790b4, 
    garray=garray@entry=0x8053e24 <a2l1x_2C>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80790b4, garray0=0x8053e24 <a2l1x_2C>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8450) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8450) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8450) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8450) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80790c0, garray0=0x8053e1c <a2l1x_2D>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80790c0, 
    garray=garray@entry=0x8053e1c <a2l1x_2D>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80790c0, garray0=0x8053e1c <a2l1x_2D>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120123) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120123) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120123) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120123) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80790cc, garray0=0x8053e14 <a2l1x_2E>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80790cc, 
    garray=garray@entry=0x8053e14 <a2l1x_2E>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80790cc, garray0=0x8053e14 <a2l1x_2E>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120124) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120124) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120124) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120124) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80790d8, garray0=0x8053e0c <a2l1x_2F>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80790d8, 
    garray=garray@entry=0x8053e0c <a2l1x_2F>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80790d8, garray0=0x8053e0c <a2l1x_2F>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120125) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120125) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120125) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120125) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80790e4, garray0=0x8053e04 <a2l1x_2G>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80790e4, 
    garray=garray@entry=0x8053e04 <a2l1x_2G>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80790e4, garray0=0x8053e04 <a2l1x_2G>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120126) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120126) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120126) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120126) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80790f0, garray0=0x8053dfc <a2l1x_2H>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80790f0, 
    garray=garray@entry=0x8053dfc <a2l1x_2H>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80790f0, garray0=0x8053dfc <a2l1x_2H>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8461) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8461) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8461) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8461) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80790fc, garray0=0x8053df4 <a2l1x_2I>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80790fc, 
    garray=garray@entry=0x8053df4 <a2l1x_2I>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80790fc, garray0=0x8053df4 <a2l1x_2I>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120128) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120128) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120128) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120128) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079108, garray0=0x8053dec <a2l1x_2J>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079108, 
    garray=garray@entry=0x8053dec <a2l1x_2J>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079108, garray0=0x8053dec <a2l1x_2J>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120129) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120129) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120129) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120129) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079114, garray0=0x8053de4 <a2l1x_2K>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079114, 
    garray=garray@entry=0x8053de4 <a2l1x_2K>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079114, garray0=0x8053de4 <a2l1x_2K>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120130) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120130) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120130) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120130) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079120, garray0=0x8053ddc <a2l1x_2L>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079120, 
    garray=garray@entry=0x8053ddc <a2l1x_2L>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079120, garray0=0x8053ddc <a2l1x_2L>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120131) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120131) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120131) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120131) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807912c, garray0=0x8053dd4 <a2l1x_2M>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807912c, 
    garray=garray@entry=0x8053dd4 <a2l1x_2M>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807912c, garray0=0x8053dd4 <a2l1x_2M>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120132) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120132) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120132) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120132) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079138, garray0=0x8053dcc <a2l1x_2>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079138, 
    garray=garray@entry=0x8053dcc <a2l1x_2>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079138, garray0=0x8053dcc <a2l1x_2>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8469) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8469) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8469) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8469) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079144, garray0=0x8053dc4 <a2l1x_2O>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079144, 
    garray=garray@entry=0x8053dc4 <a2l1x_2O>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079144, garray0=0x8053dc4 <a2l1x_2O>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120134) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120134) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120134) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120134) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079150, garray0=0x8053dbc <a2l1x_2P>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079150, 
    garray=garray@entry=0x8053dbc <a2l1x_2P>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079150, garray0=0x8053dbc <a2l1x_2P>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8473) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8473) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8473) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8473) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807915c, garray0=0x8053db4 <a2l1x_2Q>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807915c, 
    garray=garray@entry=0x8053db4 <a2l1x_2Q>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807915c, garray0=0x8053db4 <a2l1x_2Q>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8474) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8474) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8474) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8474) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079168, garray0=0x8053dac <a2l1x_2R>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079168, 
    garray=garray@entry=0x8053dac <a2l1x_2R>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079168, garray0=0x8053dac <a2l1x_2R>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8477) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8477) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8477) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8477) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079174, garray0=0x8053da4 <a2l1x_2S>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079174, 
    garray=garray@entry=0x8053da4 <a2l1x_2S>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079174, garray0=0x8053da4 <a2l1x_2S>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120138) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120138) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120138) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120138) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079180, garray0=0x8053d9c <a2l1x_2T>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079180, 
    garray=garray@entry=0x8053d9c <a2l1x_2T>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079180, garray0=0x8053d9c <a2l1x_2T>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120139) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120139) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120139) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120139) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807918c, garray0=0x8053d94 <a2l1x_2U>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807918c, 
    garray=garray@entry=0x8053d94 <a2l1x_2U>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807918c, garray0=0x8053d94 <a2l1x_2U>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120140) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120140) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120140) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120140) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079198, garray0=0x8053d8c <a2l1x_2V>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079198, 
    garray=garray@entry=0x8053d8c <a2l1x_2V>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079198, garray0=0x8053d8c <a2l1x_2V>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120141) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120141) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120141) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120141) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80791a4, garray0=0x8053d84 <a2l1x_2W>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80791a4, 
    garray=garray@entry=0x8053d84 <a2l1x_2W>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80791a4, garray0=0x8053d84 <a2l1x_2W>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120142) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120142) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120142) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120142) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80791b0, garray0=0x8053d7c <a2l1x_2>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80791b0, 
    garray=garray@entry=0x8053d7c <a2l1x_2>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80791b0, garray0=0x8053d7c <a2l1x_2>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120143) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120143) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120143) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120143) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80791bc, garray0=0x8053d74 <a2l1x_2Y>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80791bc, 
    garray=garray@entry=0x8053d74 <a2l1x_2Y>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80791bc, garray0=0x8053d74 <a2l1x_2Y>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120144) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120144) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120144) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120144) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80791c8, garray0=0x8053d6c <a2l1x_2Z>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80791c8, 
    garray=garray@entry=0x8053d6c <a2l1x_2Z>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80791c8, garray0=0x8053d6c <a2l1x_2Z>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8484) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8484) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8484) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8484) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80791d4, garray0=0x8053d64 <a2l1x_2a>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80791d4, 
    garray=garray@entry=0x8053d64 <a2l1x_2a>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80791d4, garray0=0x8053d64 <a2l1x_2a>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120146) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120146) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120146) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120146) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80791e0, garray0=0x8053d5c <a2l1x_2b>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80791e0, 
    garray=garray@entry=0x8053d5c <a2l1x_2b>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80791e0, garray0=0x8053d5c <a2l1x_2b>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120147) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120147) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120147) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120147) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80791ec, garray0=0x8053d54 <a2l1x_2c>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80791ec, 
    garray=garray@entry=0x8053d54 <a2l1x_2c>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80791ec, garray0=0x8053d54 <a2l1x_2c>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120148) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120148) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120148) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120148) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80791f8, garray0=0x8053d4c <a2l1x_2d>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80791f8, 
    garray=garray@entry=0x8053d4c <a2l1x_2d>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80791f8, garray0=0x8053d4c <a2l1x_2d>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120149) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120149) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120149) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120149) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079204, garray0=0x8053d44 <a2l1x_2e>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079204, 
    garray=garray@entry=0x8053d44 <a2l1x_2e>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079204, garray0=0x8053d44 <a2l1x_2e>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120150) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120150) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120150) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120150) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079210, garray0=0x8053d3c <a2l1x_2f>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079210, 
    garray=garray@entry=0x8053d3c <a2l1x_2f>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079210, garray0=0x8053d3c <a2l1x_2f>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120151) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120151) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120151) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120151) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807921c, garray0=0x8053d34 <a2l1x_2g>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807921c, 
    garray=garray@entry=0x8053d34 <a2l1x_2g>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807921c, garray0=0x8053d34 <a2l1x_2g>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120152) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120152) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120152) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120152) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079228, garray0=0x8053d2c <a2l1x_2h>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079228, 
    garray=garray@entry=0x8053d2c <a2l1x_2h>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079228, garray0=0x8053d2c <a2l1x_2h>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120153) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120153) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120153) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120153) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079234, garray0=0x8053d24 <a2l1x_2i>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079234, 
    garray=garray@entry=0x8053d24 <a2l1x_2i>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079234, garray0=0x8053d24 <a2l1x_2i>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120154) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120154) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120154) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120154) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079240, garray0=0x8053d1c <a2l1x_2j>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079240, 
    garray=garray@entry=0x8053d1c <a2l1x_2j>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079240, garray0=0x8053d1c <a2l1x_2j>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120155) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120155) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120155) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120155) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807924c, garray0=0x8053d14 <a2l1x_2k>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807924c, 
    garray=garray@entry=0x8053d14 <a2l1x_2k>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807924c, garray0=0x8053d14 <a2l1x_2k>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120156) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120156) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120156) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120156) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079258, garray0=0x8053d0c <a2l1x_2l>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079258, 
    garray=garray@entry=0x8053d0c <a2l1x_2l>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079258, garray0=0x8053d0c <a2l1x_2l>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120157) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120157) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120157) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120157) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079264, garray0=0x8053d04 <a2l1x_2m>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079264, 
    garray=garray@entry=0x8053d04 <a2l1x_2m>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079264, garray0=0x8053d04 <a2l1x_2m>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120158) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120158) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120158) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120158) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079270, garray0=0x8053cfc <a2l1x_2n>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079270, 
    garray=garray@entry=0x8053cfc <a2l1x_2n>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079270, garray0=0x8053cfc <a2l1x_2n>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120159) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120159) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120159) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120159) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807927c, garray0=0x8053cf4 <a2l1x_2o>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807927c, 
    garray=garray@entry=0x8053cf4 <a2l1x_2o>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807927c, garray0=0x8053cf4 <a2l1x_2o>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120160) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120160) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120160) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120160) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079288, garray0=0x8053cec <a2l1x_2p>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079288, 
    garray=garray@entry=0x8053cec <a2l1x_2p>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079288, garray0=0x8053cec <a2l1x_2p>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120161) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120161) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120161) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120161) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079294, garray0=0x8053ce4 <a2l1x_2q>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079294, 
    garray=garray@entry=0x8053ce4 <a2l1x_2q>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079294, garray0=0x8053ce4 <a2l1x_2q>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120162) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120162) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120162) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120162) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80792a0, garray0=0x8053cdc <a2l1x_2r>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80792a0, 
    garray=garray@entry=0x8053cdc <a2l1x_2r>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80792a0, garray0=0x8053cdc <a2l1x_2r>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120163) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120163) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120163) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120163) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80792ac, garray0=0x8053cd4 <a2l1x_2s>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80792ac, 
    garray=garray@entry=0x8053cd4 <a2l1x_2s>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80792ac, garray0=0x8053cd4 <a2l1x_2s>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120164) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120164) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120164) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120164) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80792b8, garray0=0x8053ccc <a2l1x_2t>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80792b8, 
    garray=garray@entry=0x8053ccc <a2l1x_2t>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80792b8, garray0=0x8053ccc <a2l1x_2t>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120165) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120165) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120165) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120165) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80792c4, garray0=0x8053cc4 <a2l1x_2u>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80792c4, 
    garray=garray@entry=0x8053cc4 <a2l1x_2u>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80792c4, garray0=0x8053cc4 <a2l1x_2u>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120166) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120166) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120166) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120166) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80792d0, garray0=0x8053cbc <a2l1x_2v>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80792d0, 
    garray=garray@entry=0x8053cbc <a2l1x_2v>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80792d0, garray0=0x8053cbc <a2l1x_2v>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120167) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120167) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120167) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120167) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80792dc, garray0=0x8053cb4 <a2l1x_2w>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80792dc, 
    garray=garray@entry=0x8053cb4 <a2l1x_2w>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80792dc, garray0=0x8053cb4 <a2l1x_2w>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120168) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120168) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120168) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120168) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80792e8, garray0=0x8053cac <a2l1x_2x>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80792e8, 
    garray=garray@entry=0x8053cac <a2l1x_2x>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80792e8, garray0=0x8053cac <a2l1x_2x>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120169) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120169) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120169) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120169) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80792f4, garray0=0x8053ca4 <a2l1x_2y>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80792f4, 
    garray=garray@entry=0x8053ca4 <a2l1x_2y>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80792f4, garray0=0x8053ca4 <a2l1x_2y>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120170) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120170) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120170) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120170) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079300, garray0=0x8053c9c <a2l1x_2z>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079300, 
    garray=garray@entry=0x8053c9c <a2l1x_2z>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079300, garray0=0x8053c9c <a2l1x_2z>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120171) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120171) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120171) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120171) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807930c, 
    garray0=0x8053c94 <a2l1x_2zero>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807930c, 
    garray=garray@entry=0x8053c94 <a2l1x_2zero>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807930c, 
    garray0=0x8053c94 <a2l1x_2zero>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120792) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120792) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120792) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120792) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120792) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120792) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079318, 
    garray0=0x8053c8c <a2l1x_2one>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079318, 
    garray=garray@entry=0x8053c8c <a2l1x_2one>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079318, 
    garray0=0x8053c8c <a2l1x_2one>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120793) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120793) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120793) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120793) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079324, 
    garray0=0x8053c84 <a2l1x_2two>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079324, 
    garray=garray@entry=0x8053c84 <a2l1x_2two>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079324, 
    garray0=0x8053c84 <a2l1x_2two>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120794) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120794) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120794) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120794) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079330, 
    garray0=0x8053c7c <a2l1x_2three>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079330, 
    garray=garray@entry=0x8053c7c <a2l1x_2three>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079330, 
    garray0=0x8053c7c <a2l1x_2three>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120795) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120795) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120795) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120795) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807933c, 
    garray0=0x8053c74 <a2l1x_2four>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807933c, 
    garray=garray@entry=0x8053c74 <a2l1x_2four>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807933c, 
    garray0=0x8053c74 <a2l1x_2four>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120796) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120796) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120796) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120796) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079348, 
    garray0=0x8053c6c <a2l1x_2five>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079348, 
    garray=garray@entry=0x8053c6c <a2l1x_2five>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079348, 
    garray0=0x8053c6c <a2l1x_2five>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120797) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120797) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120797) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120797) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079354, 
    garray0=0x8053c64 <a2l1x_2six>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079354, 
    garray=garray@entry=0x8053c64 <a2l1x_2six>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079354, 
    garray0=0x8053c64 <a2l1x_2six>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120798) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120798) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120798) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120798) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079360, 
    garray0=0x8053c5c <a2l1x_2seven>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079360, 
    garray=garray@entry=0x8053c5c <a2l1x_2seven>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079360, 
    garray0=0x8053c5c <a2l1x_2seven>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120799) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120799) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120799) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120799) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807936c, 
    garray0=0x8053c54 <a2l1x_2eight>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807936c, 
    garray=garray@entry=0x8053c54 <a2l1x_2eight>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807936c, 
    garray0=0x8053c54 <a2l1x_2eight>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=7648) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=7648) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=7648) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=7648) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=7648) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
108	    	    for( ; shift > 0; shift -= SPAR_BITS_PER_STAGE) {
113		    p->children = spar_new_block(this->default_leaf);
spar_new_block (fill_with=...) at sparse.c:126
126	{
129	    p = xmalloc(SPAR_NODES_PER_BLOCK * sizeof(spar_node_t));
util_xmalloc (size=size@entry=1024, file=file@entry=0x80556f8 "sparse.c", 
    line=line@entry=129) at util.c:108
108	{
111	    res = malloc(size);
112	    if(res == NULL && size != 0) panic(util_oom_format, file, line);
114	}
spar_new_block (fill_with=...) at sparse.c:130
130	    for(q = p; q < p + SPAR_NODES_PER_BLOCK; ++q) *q = fill_with;
132	}
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=7648) at sparse.c:114
114		    p = p->children + (i & SPAR_STAGE_MASK);
113		    p->children = spar_new_block(this->default_leaf);
122	}
116		    return p;
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079378, 
    garray0=0x8053c4c <a2l1x_2nine>) at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079378, 
    garray=garray@entry=0x8053c4c <a2l1x_2nine>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079378, 
    garray0=0x8053c4c <a2l1x_2nine>) at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=7649) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=7649) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=7649) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=7649) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079384, garray0=0x8053e34 <a2l1x_2A>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079384, 
    garray=garray@entry=0x8053e34 <a2l1x_2A>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079384, garray0=0x8053e34 <a2l1x_2A>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120068) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120068) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120068) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120068) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079390, garray0=0x8053e2c <a2l1x_2>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079390, 
    garray=garray@entry=0x8053e2c <a2l1x_2>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079390, garray0=0x8053e2c <a2l1x_2>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120069) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120069) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120069) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120069) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807939c, garray0=0x8053e24 <a2l1x_2C>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807939c, 
    garray=garray@entry=0x8053e24 <a2l1x_2C>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807939c, garray0=0x8053e24 <a2l1x_2C>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8493) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8493) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8493) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8493) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80793a8, garray0=0x8053e1c <a2l1x_2D>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80793a8, 
    garray=garray@entry=0x8053e1c <a2l1x_2D>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80793a8, garray0=0x8053e1c <a2l1x_2D>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120071) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120071) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120071) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120071) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80793b4, garray0=0x8053e14 <a2l1x_2E>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80793b4, 
    garray=garray@entry=0x8053e14 <a2l1x_2E>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80793b4, garray0=0x8053e14 <a2l1x_2E>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120072) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120072) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120072) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120072) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80793c0, garray0=0x8053e0c <a2l1x_2F>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80793c0, 
    garray=garray@entry=0x8053e0c <a2l1x_2F>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80793c0, garray0=0x8053e0c <a2l1x_2F>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120073) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120073) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120073) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120073) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80793cc, garray0=0x8053e04 <a2l1x_2G>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80793cc, 
    garray=garray@entry=0x8053e04 <a2l1x_2G>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80793cc, garray0=0x8053e04 <a2l1x_2G>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120074) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120074) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120074) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120074) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80793d8, garray0=0x8053dfc <a2l1x_2H>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80793d8, 
    garray=garray@entry=0x8053dfc <a2l1x_2H>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80793d8, garray0=0x8053dfc <a2l1x_2H>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8460) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8460) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8460) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8460) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80793e4, garray0=0x8053df4 <a2l1x_2I>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80793e4, 
    garray=garray@entry=0x8053df4 <a2l1x_2I>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80793e4, garray0=0x8053df4 <a2l1x_2I>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8465) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8465) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8465) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8465) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80793f0, garray0=0x8053dec <a2l1x_2J>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80793f0, 
    garray=garray@entry=0x8053dec <a2l1x_2J>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80793f0, garray0=0x8053dec <a2l1x_2J>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120077) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120077) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120077) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120077) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80793fc, garray0=0x8053de4 <a2l1x_2K>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80793fc, 
    garray=garray@entry=0x8053de4 <a2l1x_2K>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80793fc, garray0=0x8053de4 <a2l1x_2K>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120078) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120078) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120078) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120078) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079408, garray0=0x8053ddc <a2l1x_2L>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079408, 
    garray=garray@entry=0x8053ddc <a2l1x_2L>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079408, garray0=0x8053ddc <a2l1x_2L>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120079) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120079) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120079) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120079) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079414, garray0=0x8053dd4 <a2l1x_2M>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079414, 
    garray=garray@entry=0x8053dd4 <a2l1x_2M>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079414, garray0=0x8053dd4 <a2l1x_2M>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120080) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120080) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120080) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120080) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079420, garray0=0x8053dcc <a2l1x_2>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079420, 
    garray=garray@entry=0x8053dcc <a2l1x_2>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079420, garray0=0x8053dcc <a2l1x_2>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120081) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120081) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120081) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120081) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807942c, garray0=0x8053dc4 <a2l1x_2O>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807942c, 
    garray=garray@entry=0x8053dc4 <a2l1x_2O>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807942c, garray0=0x8053dc4 <a2l1x_2O>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120082) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120082) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120082) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120082) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079438, garray0=0x8053dbc <a2l1x_2P>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079438, 
    garray=garray@entry=0x8053dbc <a2l1x_2P>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079438, garray0=0x8053dbc <a2l1x_2P>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120083) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120083) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120083) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120083) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079444, garray0=0x8053db4 <a2l1x_2Q>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079444, 
    garray=garray@entry=0x8053db4 <a2l1x_2Q>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079444, garray0=0x8053db4 <a2l1x_2Q>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120084) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120084) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120084) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120084) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079450, garray0=0x8053dac <a2l1x_2R>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079450, 
    garray=garray@entry=0x8053dac <a2l1x_2R>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079450, garray0=0x8053dac <a2l1x_2R>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8476) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8476) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8476) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8476) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807945c, garray0=0x8053da4 <a2l1x_2S>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807945c, 
    garray=garray@entry=0x8053da4 <a2l1x_2S>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807945c, garray0=0x8053da4 <a2l1x_2S>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120086) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120086) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120086) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120086) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079468, garray0=0x8053d9c <a2l1x_2T>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079468, 
    garray=garray@entry=0x8053d9c <a2l1x_2T>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079468, garray0=0x8053d9c <a2l1x_2T>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120087) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120087) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120087) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120087) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079474, garray0=0x8053d94 <a2l1x_2U>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079474, 
    garray=garray@entry=0x8053d94 <a2l1x_2U>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079474, garray0=0x8053d94 <a2l1x_2U>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120088) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120088) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120088) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120088) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079480, garray0=0x8053d8c <a2l1x_2V>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079480, 
    garray=garray@entry=0x8053d8c <a2l1x_2V>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079480, garray0=0x8053d8c <a2l1x_2V>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120089) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120089) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120089) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120089) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807948c, garray0=0x8053d84 <a2l1x_2W>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807948c, 
    garray=garray@entry=0x8053d84 <a2l1x_2W>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807948c, garray0=0x8053d84 <a2l1x_2W>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120090) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120090) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120090) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120090) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079498, garray0=0x8053d7c <a2l1x_2>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079498, 
    garray=garray@entry=0x8053d7c <a2l1x_2>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079498, garray0=0x8053d7c <a2l1x_2>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120091) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120091) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120091) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120091) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80794a4, garray0=0x8053d74 <a2l1x_2Y>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80794a4, 
    garray=garray@entry=0x8053d74 <a2l1x_2Y>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80794a4, garray0=0x8053d74 <a2l1x_2Y>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120092) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120092) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120092) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120092) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80794b0, garray0=0x8053d6c <a2l1x_2Z>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80794b0, 
    garray=garray@entry=0x8053d6c <a2l1x_2Z>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80794b0, garray0=0x8053d6c <a2l1x_2Z>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8488) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=8488) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8488) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=8488) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80794bc, garray0=0x8053d64 <a2l1x_2a>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80794bc, 
    garray=garray@entry=0x8053d64 <a2l1x_2a>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80794bc, garray0=0x8053d64 <a2l1x_2a>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120094) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120094) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120094) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120094) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80794c8, garray0=0x8053d5c <a2l1x_2b>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80794c8, 
    garray=garray@entry=0x8053d5c <a2l1x_2b>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80794c8, garray0=0x8053d5c <a2l1x_2b>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120095) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120095) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120095) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120095) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80794d4, garray0=0x8053d54 <a2l1x_2c>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80794d4, 
    garray=garray@entry=0x8053d54 <a2l1x_2c>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80794d4, garray0=0x8053d54 <a2l1x_2c>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120096) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120096) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120096) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120096) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80794e0, garray0=0x8053d4c <a2l1x_2d>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80794e0, 
    garray=garray@entry=0x8053d4c <a2l1x_2d>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80794e0, garray0=0x8053d4c <a2l1x_2d>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120097) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120097) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120097) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120097) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80794ec, garray0=0x8053d44 <a2l1x_2e>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80794ec, 
    garray=garray@entry=0x8053d44 <a2l1x_2e>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80794ec, garray0=0x8053d44 <a2l1x_2e>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120098) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120098) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120098) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120098) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80794f8, garray0=0x8053d3c <a2l1x_2f>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80794f8, 
    garray=garray@entry=0x8053d3c <a2l1x_2f>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80794f8, garray0=0x8053d3c <a2l1x_2f>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120099) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120099) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120099) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120099) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079504, garray0=0x8053d34 <a2l1x_2g>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079504, 
    garray=garray@entry=0x8053d34 <a2l1x_2g>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079504, garray0=0x8053d34 <a2l1x_2g>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120100) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120100) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120100) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120100) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079510, garray0=0x8053d2c <a2l1x_2h>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079510, 
    garray=garray@entry=0x8053d2c <a2l1x_2h>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079510, garray0=0x8053d2c <a2l1x_2h>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120101) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120101) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120101) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120101) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807951c, garray0=0x8053d24 <a2l1x_2i>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807951c, 
    garray=garray@entry=0x8053d24 <a2l1x_2i>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807951c, garray0=0x8053d24 <a2l1x_2i>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120102) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120102) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120102) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120102) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079528, garray0=0x8053d1c <a2l1x_2j>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079528, 
    garray=garray@entry=0x8053d1c <a2l1x_2j>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079528, garray0=0x8053d1c <a2l1x_2j>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120103) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120103) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120103) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120103) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079534, garray0=0x8053d14 <a2l1x_2k>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079534, 
    garray=garray@entry=0x8053d14 <a2l1x_2k>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079534, garray0=0x8053d14 <a2l1x_2k>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120104) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120104) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120104) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120104) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079540, garray0=0x8053d0c <a2l1x_2l>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079540, 
    garray=garray@entry=0x8053d0c <a2l1x_2l>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079540, garray0=0x8053d0c <a2l1x_2l>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120105) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120105) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120105) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120105) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807954c, garray0=0x8053d04 <a2l1x_2m>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807954c, 
    garray=garray@entry=0x8053d04 <a2l1x_2m>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807954c, garray0=0x8053d04 <a2l1x_2m>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120106) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120106) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120106) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120106) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079558, garray0=0x8053cfc <a2l1x_2n>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079558, 
    garray=garray@entry=0x8053cfc <a2l1x_2n>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079558, garray0=0x8053cfc <a2l1x_2n>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120107) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120107) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120107) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120107) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079564, garray0=0x8053cf4 <a2l1x_2o>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079564, 
    garray=garray@entry=0x8053cf4 <a2l1x_2o>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079564, garray0=0x8053cf4 <a2l1x_2o>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120108) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120108) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120108) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120108) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079570, garray0=0x8053cec <a2l1x_2p>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079570, 
    garray=garray@entry=0x8053cec <a2l1x_2p>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079570, garray0=0x8053cec <a2l1x_2p>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120109) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120109) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120109) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120109) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x807957c, garray0=0x8053ce4 <a2l1x_2q>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x807957c, 
    garray=garray@entry=0x8053ce4 <a2l1x_2q>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x807957c, garray0=0x8053ce4 <a2l1x_2q>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120110) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120110) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120110) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120110) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079588, garray0=0x8053cdc <a2l1x_2r>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079588, 
    garray=garray@entry=0x8053cdc <a2l1x_2r>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079588, garray0=0x8053cdc <a2l1x_2r>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120111) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120111) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120111) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120111) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x8079594, garray0=0x8053cd4 <a2l1x_2s>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x8079594, 
    garray=garray@entry=0x8053cd4 <a2l1x_2s>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x8079594, garray0=0x8053cd4 <a2l1x_2s>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120112) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120112) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120112) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120112) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80795a0, garray0=0x8053ccc <a2l1x_2t>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80795a0, 
    garray=garray@entry=0x8053ccc <a2l1x_2t>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80795a0, garray0=0x8053ccc <a2l1x_2t>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120113) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120113) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120113) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120113) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80795ac, garray0=0x8053cc4 <a2l1x_2u>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80795ac, 
    garray=garray@entry=0x8053cc4 <a2l1x_2u>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80795ac, garray0=0x8053cc4 <a2l1x_2u>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120114) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120114) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120114) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120114) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80795b8, garray0=0x8053cbc <a2l1x_2v>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80795b8, 
    garray=garray@entry=0x8053cbc <a2l1x_2v>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80795b8, garray0=0x8053cbc <a2l1x_2v>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120115) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120115) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120115) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120115) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80795c4, garray0=0x8053cb4 <a2l1x_2w>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80795c4, 
    garray=garray@entry=0x8053cb4 <a2l1x_2w>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80795c4, garray0=0x8053cb4 <a2l1x_2w>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120116) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120116) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120116) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120116) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80795d0, garray0=0x8053cac <a2l1x_2x>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80795d0, 
    garray=garray@entry=0x8053cac <a2l1x_2x>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80795d0, garray0=0x8053cac <a2l1x_2x>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120117) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120117) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120117) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120117) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80795dc, garray0=0x8053ca4 <a2l1x_2y>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80795dc, 
    garray=garray@entry=0x8053ca4 <a2l1x_2y>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80795dc, garray0=0x8053ca4 <a2l1x_2y>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120118) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120118) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120118) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120118) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1332	    	tweak = tweaks[i];
1333	    	assert(tweak.width != WIDTH_AUTO || tweak.xlat != NULL);
1336		    linebuf_garray0_init(px+i, tweak.xlat);
linebuf_garray0_init (this=this@entry=0x80795e8, garray0=0x8053c9c <a2l1x_2z>)
    at linebuf.c:50
50	{
52	    while(garray0[len] != 0) ++len;
51	    int len = 0;
52	    while(garray0[len] != 0) ++len;
53	    linebuf_garray_init(this, garray0, len);
linebuf_garray_init (this=this@entry=0x80795e8, 
    garray=garray@entry=0x8053c9c <a2l1x_2z>, len=1) at linebuf.c:38
38	{
39	    this->size_curr = len;
40	    this->size_alloc = len + 1;
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
42	    this->gstring = malloc(this->size_alloc * sizeof(glyph_t));
43	    if(!this->gstring) enomem();
45	    memcpy(this->gstring, garray, sizeof(glyph_t) * this->size_alloc);
46	    this->gstring[this->size_curr] = 0;
47	}
linebuf_garray0_init (this=this@entry=0x80795e8, garray0=0x8053c9c <a2l1x_2z>)
    at linebuf.c:54
54	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1337
1337		    sparp_write(&glyphxlat_sparp, tweak.glyph, px+i);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120119) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf24 <glyphxlat_sparp>, 
    i=i@entry=120119) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1338
1338		    if(tweak.width == WIDTH_AUTO) tweak.width = px[i].size_curr;
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120119) at sparse.c:96
96	{
100	    while(i > this->max_index) spar_grow(this);
0x0804f05d in spar_grow (this=<optimized out>) at sparse.c:158
158	    	p = spar_new_block(this->default_leaf);
spar_assignable_entry (this=this@entry=0x806bf38 <glyphwidth_spars32>, 
    i=i@entry=120119) at sparse.c:103
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
102	    p = &(this->root);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
104	    	if(p->children == NULL) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
118		p = p->children + ((i >> shift) & SPAR_STAGE_MASK);
103	    for(shift = this->max_shift; shift >= 0; shift -= SPAR_BITS_PER_STAGE) {
122	}
102	    p = &(this->root);
122	}
outenc_register_glyphtweaks (tweaks=tweaks@entry=0x8053460 <a2l1_glyphtweaks>, 
    length=length@entry=169) at outenc.c:1331
1331	    for(i=0; i < length; ++i) {
1340		spars32_write(&glyphwidth_spars32, tweak.glyph, tweak.width);
1331	    for(i=0; i < length; ++i) {
1343	}
ascii_init () at outenc.c:956
956	    simple_init_charmap(127, NULL, 0);
simple_init_charmap (identity_range=identity_range@entry=127 '\177', 
    charmap_tbl=charmap_tbl@entry=0x0, tbl_length=tbl_length@entry=0)
    at outenc.c:468
468	{
473	    for(i = 0; i < tbl_length; ++i) {
468	{
472	    spars32_init(&simple_charmap_spars32, 0);
471	    simple_identity_range = identity_range;
472	    spars32_init(&simple_charmap_spars32, 0);
spars32_init (this=this@entry=0x806bf50 <simple_charmap_spars32>, 
    default_value=default_value@entry=0) at sparse.c:192
192	void spars32_init(spars32_t * this, sint32 default_value) {
196	    spar_init(&this->s32_spar, default_leaf);
spar_init (default_entry=..., 
    this=this@entry=0x806bf50 <simple_charmap_spars32>) at sparse.c:58
58	    this->height = 0;
59	    this->max_shift = - SPAR_BITS_PER_STAGE;
60	    this->max_index = 0;
61	    this->default_leaf = default_entry;
64	    this->root = default_entry;
simple_init_charmap (identity_range=identity_range@entry=127 '\177', 
    charmap_tbl=charmap_tbl@entry=0x0, tbl_length=tbl_length@entry=0)
    at outenc.c:473
473	    for(i = 0; i < tbl_length; ++i) {
481	}
ascii_init () at outenc.c:958
958	    outenc_write_raw_glyph = simple_write_raw_glyph;
959	    outenc_composition_width = generic_composition_width;
960	    outenc_xlat_composition = generic_xlat_composition;
outenc_init () at outenc.c:1232
1232	    assert(outenc_xlat_composition != NULL);
1233	    assert(outenc_write_raw_glyph != NULL);
1235	    pmesg(50, "END outenc_init\n");
pmesg (level=level@entry=50, format=format@entry=0x8053292 "END outenc_init\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
outenc_init () at outenc.c:1236
1236	}
main (argc=3, argv=0xbfffe864) at catdvi.c:240
240	        process_file(dvifile);
process_file (f=f@entry=0x806eb68) at readdvi.c:157
157	void process_file(FILE *f) {
165	        efread(&b, 1, 1, f, "Could not read initial byte\n");
157	void process_file(FILE *f) {
165	        efread(&b, 1, 1, f, "Could not read initial byte\n");
efread (ptr=ptr@entry=0xbfffa75a, size=size@entry=1, nmemb=nmemb@entry=1, 
    stream=stream@entry=0x806eb68, 
    errmsg=errmsg@entry=0x8055019 "Could not read initial byte\n")
    at bytesex.c:32
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
41	}
process_file (f=f@entry=0x806eb68) at readdvi.c:166
166	        if (b != DVI_pre)
168	        pmesg(100, "Read preamble byte\n");
pmesg (level=level@entry=100, 
    format=format@entry=0x8055054 "Read preamble byte\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
process_file (f=f@entry=0x806eb68) at readdvi.c:170
170	        efread(&b, 1, 1, f, "Could not read second byte\n");
efread (ptr=ptr@entry=0xbfffa75a, size=size@entry=1, nmemb=nmemb@entry=1, 
    stream=stream@entry=0x806eb68, 
    errmsg=errmsg@entry=0x8055068 "Could not read second byte\n")
    at bytesex.c:32
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
41	}
process_file (f=f@entry=0x806eb68) at readdvi.c:171
171	        if (b != 2)
173	        pmesg(100, "Read identification byte\n");
pmesg (level=level@entry=100, 
    format=format@entry=0x805509f "Read identification byte\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
process_file (f=f@entry=0x806eb68) at readdvi.c:175
175	        num = u_readbigendiannumber(4, f);
u_readbigendiannumber (count=count@entry=4 '\004', 
    stream=stream@entry=0x806eb68) at bytesex.c:54
54	{
59	        assert(count <= 4);
61	    	efread(buf, count, 1, stream, "Failed to read big endian number.\n");
efread (ptr=0xbfffa6e8, size=4, nmemb=1, stream=0x806eb68, 
    errmsg=0x805288c "Failed to read big endian number.\n") at bytesex.c:32
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
41	}
u_readbigendiannumber (count=count@entry=4 '\004', 
    stream=stream@entry=0x806eb68) at bytesex.c:65
65	        for (i = 0; i < count; i++) {
55	        uint32 ures = 0;
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
70	}
process_file (f=f@entry=0x806eb68) at readdvi.c:176
176	        pmesg(80, "Read numerator: %li\n", num);
pmesg (level=level@entry=80, 
    format=format@entry=0x80550b9 "Read numerator: %li\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
process_file (f=f@entry=0x806eb68) at readdvi.c:178
178	        den = u_readbigendiannumber(4, f);
u_readbigendiannumber (count=count@entry=4 '\004', 
    stream=stream@entry=0x806eb68) at bytesex.c:54
54	{
59	        assert(count <= 4);
61	    	efread(buf, count, 1, stream, "Failed to read big endian number.\n");
efread (ptr=0xbfffa6e8, size=4, nmemb=1, stream=0x806eb68, 
    errmsg=0x805288c "Failed to read big endian number.\n") at bytesex.c:32
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
41	}
u_readbigendiannumber (count=count@entry=4 '\004', 
    stream=stream@entry=0x806eb68) at bytesex.c:65
65	        for (i = 0; i < count; i++) {
55	        uint32 ures = 0;
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
70	}
process_file (f=f@entry=0x806eb68) at readdvi.c:179
179	        pmesg(80, "Read denominator: %li\n", den);
178	        den = u_readbigendiannumber(4, f);
179	        pmesg(80, "Read denominator: %li\n", den);
pmesg (level=level@entry=80, 
    format=format@entry=0x80550ce "Read denominator: %li\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
process_file (f=f@entry=0x806eb68) at readdvi.c:181
181	        conversion = ((double) num) / ((double) den);
183	        magnification = s_readbigendiannumber(4, f);
181	        conversion = ((double) num) / ((double) den);
161	        sint32 currfont = 0;
181	        conversion = ((double) num) / ((double) den);
183	        magnification = s_readbigendiannumber(4, f);
s_readbigendiannumber (count=count@entry=4 '\004', 
    stream=stream@entry=0x806eb68) at bytesex.c:75
75	{
77	        const uint32 msb_bitmask = ((uint32) 1) << (8 * count - 1);
75	{
77	        const uint32 msb_bitmask = ((uint32) 1) << (8 * count - 1);
82	        assert(count <= 4);
80	        const uint32 allset_bitmask = msb_bitmask + (msb_bitmask - 1);
82	        assert(count <= 4);
85	        ures = u_readbigendiannumber(count, stream);
u_readbigendiannumber (count=4 '\004', stream=0x806eb68) at bytesex.c:54
54	{
59	        assert(count <= 4);
61	    	efread(buf, count, 1, stream, "Failed to read big endian number.\n");
efread (ptr=0xbfffa6c8, size=4, nmemb=1, stream=0x806eb68, 
    errmsg=0x805288c "Failed to read big endian number.\n") at bytesex.c:32
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
41	}
u_readbigendiannumber (count=4 '\004', stream=0x806eb68) at bytesex.c:65
65	        for (i = 0; i < count; i++) {
55	        uint32 ures = 0;
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
66	                ures = (ures << 8) + buf[i];
65	        for (i = 0; i < count; i++) {
70	}
s_readbigendiannumber (count=count@entry=4 '\004', 
    stream=stream@entry=0x806eb68) at bytesex.c:87
87	        assert(ures <= allset_bitmask);
93	        if (ures >= msb_bitmask) {
95	                return - (sint32) (ures ^ allset_bitmask) - 1;
101	}
process_file (f=f@entry=0x806eb68) at readdvi.c:184
184	        pmesg(80, "Read magnification: %li\n", magnification);
183	        magnification = s_readbigendiannumber(4, f);
184	        pmesg(80, "Read magnification: %li\n", magnification);
pmesg (level=level@entry=80, 
    format=format@entry=0x80550e5 "Read magnification: %li\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
process_file (f=f@entry=0x806eb68) at readdvi.c:186
186	        efread(&b, 1, 1, f, "Could not read comment length\n");
efread (ptr=ptr@entry=0xbfffa75a, size=size@entry=1, nmemb=nmemb@entry=1, 
    stream=stream@entry=0x806eb68, 
    errmsg=errmsg@entry=0x8054f6c "Could not read comment length\n")
    at bytesex.c:32
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
41	}
process_file (f=f@entry=0x806eb68) at readdvi.c:187
187	        pmesg(100, "Read comment length: %i\n", b);
pmesg (level=level@entry=100, 
    format=format@entry=0x80550fe "Read comment length: %i\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
process_file (f=f@entry=0x806eb68) at readdvi.c:188
188	        efread(comment, 1, b, f, "Could not read comment\n");
efread (ptr=ptr@entry=0xbfffa75b, size=size@entry=1, nmemb=0, 
    stream=stream@entry=0x806eb68, 
    errmsg=errmsg@entry=0x8055117 "Could not read comment\n") at bytesex.c:32
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
41	}
process_file (f=f@entry=0x806eb68) at readdvi.c:189
189	        comment[b+1] = '\0';
190	        pmesg(80, "Read comment: `%s'\n", comment);
pmesg (level=level@entry=80, 
    format=format@entry=0x805512f "Read comment: `%s'\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
process_file (f=f@entry=0x806eb68) at readdvi.c:195
195	                efread(&b, 1, 1, f, "Failed to read opcode byte\n");
efread (ptr=ptr@entry=0xbfffa75a, size=size@entry=1, nmemb=nmemb@entry=1, 
    stream=stream@entry=0x806eb68, 
    errmsg=errmsg@entry=0x8055143 "Failed to read opcode byte\n")
    at bytesex.c:32
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
32	{
33	        if (fread(ptr, size, nmemb, stream) != nmemb) {
41	}
process_file (f=f@entry=0x806eb68) at readdvi.c:197
197	                if (b == DVI_post)
200	                if ((b >= DVI_set_char_0) && (b <= DVI_set_char_127)) {
201	                        c = b;
202	                        pmesg(80, "[set char %i: %c]\n", b-DVI_set_char_0, (unsigned char) (b-DVI_set_char_0));
pmesg (level=level@entry=80, 
    format=format@entry=0x805515f "[set char %i: %c]\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
process_file (f=f@entry=0x806eb68) at readdvi.c:203
203	                        output_glyph(currfont, b-DVI_set_char_0);
output_glyph (font=font@entry=0, glyph=0) at readdvi.c:116
116	{
122	        if (font != currfont) {
126	            currfenc = find_fntenc(font_enc(font), font_family(font));
125	            currfont = font;
126	            currfenc = find_fntenc(font_enc(font), font_family(font));
font_family (k=k@entry=0) at fontinfo.c:406
406	{
408	        if (k < 0 || k >= LEN_TFM_TBL) {
412	        return tfm_tbl[k].family;
413	}
412	        return tfm_tbl[k].family;
413	}
font_enc (k=k@entry=0) at fontinfo.c:396
396	{
397	        if (k < 0 || k >= LEN_TFM_TBL) {
401	        pmesg(80, "[font %li, encoding: %s]\n", k, tfm_tbl[k].encoding);
pmesg (level=level@entry=80, 
    format=format@entry=0x8052d3b "[font %li, encoding: %s]\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
font_enc (k=k@entry=0) at fontinfo.c:403
403	}
402	        return tfm_tbl[k].encoding;
403	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:92
92	{
97	        if (encname == 0 || family == 0) return rv;
99	        upenc = strupcasedup(encname);
strupcasedup (s=s@entry=0x805f760 <tfm_tbl+64> "") at util.c:174
174	{
177	    su = malloc(strlen(s) + 1);
178	    if (su == NULL) return NULL;
177	    su = malloc(strlen(s) + 1);
178	    if (su == NULL) return NULL;
179	    strcpy(su, s);
181	    strupcase(su);
strupcase (s=s@entry=0x807f950 "") at util.c:163
163	{
166	        for (p = s; *p !=0; ++p) {
171	}
strupcasedup (s=s@entry=0x805f760 <tfm_tbl+64> "") at util.c:184
184	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:100
100		if(upenc == NULL) enomem();
99	        upenc = strupcasedup(encname);
100		if(upenc == NULL) enomem();
101	        upfamily = strupcasedup(family);
strupcasedup (s=s@entry=0x805f788 <tfm_tbl+104> "") at util.c:174
174	{
177	    su = malloc(strlen(s) + 1);
178	    if (su == NULL) return NULL;
177	    su = malloc(strlen(s) + 1);
178	    if (su == NULL) return NULL;
179	    strcpy(su, s);
181	    strupcase(su);
strupcase (s=s@entry=0x807f960 "") at util.c:163
163	{
166	        for (p = s; *p !=0; ++p) {
171	}
strupcasedup (s=s@entry=0x805f788 <tfm_tbl+104> "") at util.c:184
184	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:102
102		if(upfamily == NULL) enomem();
101	        upfamily = strupcasedup(family);
102		if(upfamily == NULL) enomem();
92	{
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
105	                pmesg(85, "[matching fontenc %s to %s... ",
pmesg (level=level@entry=85, 
    format=format@entry=0x8052a8c "[matching fontenc %s to %s... ")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:107
107	                if (strcmp(fontenctbl[i].encname, upenc) != 0) {
108	                        pmesg(85, "failed]\n");
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
108	                        pmesg(85, "failed]\n");
pmesg (level=level@entry=85, format=format@entry=0x80528e9 "failed]\n")
    at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:104
104	        for (i = 0; i < TBLLEN(fontenctbl); i++) {
125	        warning(
93	        int rv = 0; /* default is TeX text */
125	        warning(
warning (
    format=format@entry=0x8052ad0 "unknown font encoding `%s' for family `%s', reverting to `%s'\n") at util.c:39
39	        if (!suppress_warnings) vfprintf(stderr, format, args);
36	        ++num_warnings;
39	        if (!suppress_warnings) vfprintf(stderr, format, args);
33	{
39	        if (!suppress_warnings) vfprintf(stderr, format, args);
41	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:134
134	        free(upenc);
135	        free(upfamily);
136	        pmesg(70, "[returning fontenc %i]\n", rv);
pmesg (level=level@entry=70, 
    format=format@entry=0x8052900 "[returning fontenc %i]\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
find_fntenc (encname=0x805f760 <tfm_tbl+64> "", 
    family=family@entry=0x805f788 <tfm_tbl+104> "") at fntenc.c:138
138	}
output_glyph (font=font@entry=0, glyph=0) at readdvi.c:127
127		    new_axis_height = font_axis_height(font);
126	            currfenc = find_fntenc(font_enc(font), font_family(font));
127		    new_axis_height = font_axis_height(font);
font_axis_height (font=font@entry=0) at fontinfo.c:560
560	{
561	        if (font < 0 || font >= LEN_TFM_TBL) {
565	    	return tfm_tbl[font].axis_height;
566	}
output_glyph (font=font@entry=0, glyph=0) at readdvi.c:129
129		    if(new_axis_height > 0) {
141			curr_math_axis = - font_scale_fw(font, last_axis_height);
font_scale_fw (font=font@entry=0, fw=262144) at fontinfo.c:417
417	        return fw_prod(fw, tfm_tbl[font].scale);
416	{
417	        return fw_prod(fw, tfm_tbl[font].scale);
fw_prod (a=262144, b=0) at fixword.c:32
32	{
35	        if (a < 0) return - fw_prod(-a, b);
36	        if (b < 0) return - fw_prod(a, -b);
39	        al = a & 32767;
40	        bl = b & 32767;
39	        al = a & 32767;
40	        bl = b & 32767;
44		return (((al*bl >> 15) + a*bl + al*b) >> 5) + (a*b << 10);
41	        a >>= 15;
44		return (((al*bl >> 15) + a*bl + al*b) >> 5) + (a*b << 10);
42	        b >>= 15;
44		return (((al*bl >> 15) + a*bl + al*b) >> 5) + (a*b << 10);
45	}
output_glyph (font=font@entry=0, glyph=0) at readdvi.c:145
145	        dump_regs(86);
dump_regs (level=level@entry=86) at regsta.c:100
100	{
103	    	if(level > msglevel) return;
output_glyph (font=font@entry=0, glyph=0) at readdvi.c:146
146	        pmesg(85, "OUTPUT_GLYPH: font %li, glyph %li, H %li, V %li\n",
get_reg (reg=reg@entry=1) at regsta.c:72
72	{
73	        assert(reg >= 0);
74	        assert(reg < NUM_REGS);
75	        pmesg(150, "GET_REG %s -> %li\n", regnames[reg], registers[reg]);
pmesg (level=level@entry=150, 
    format=format@entry=0x8055348 "GET_REG %s -> %li\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
get_reg (reg=reg@entry=1) at regsta.c:76
76	        return registers[reg];
77	}
get_reg (reg=reg@entry=0) at regsta.c:72
72	{
73	        assert(reg >= 0);
74	        assert(reg < NUM_REGS);
75	        pmesg(150, "GET_REG %s -> %li\n", regnames[reg], registers[reg]);
pmesg (level=level@entry=150, 
    format=format@entry=0x8055348 "GET_REG %s -> %li\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
get_reg (reg=reg@entry=0) at regsta.c:76
76	        return registers[reg];
77	}
pmesg (level=level@entry=85, 
    format=format@entry=0x8054f38 "OUTPUT_GLYPH: font %li, glyph %li, H %li, V %li\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
output_glyph (font=font@entry=0, glyph=0) at readdvi.c:149
149	        page_set_glyph(font, fnt_convert(currfenc, glyph),
get_reg (reg=reg@entry=1) at regsta.c:72
72	{
73	        assert(reg >= 0);
74	        assert(reg < NUM_REGS);
75	        pmesg(150, "GET_REG %s -> %li\n", regnames[reg], registers[reg]);
pmesg (level=level@entry=150, 
    format=format@entry=0x8055348 "GET_REG %s -> %li\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
get_reg (reg=reg@entry=1) at regsta.c:76
76	        return registers[reg];
77	}
get_reg (reg=reg@entry=0) at regsta.c:72
72	{
73	        assert(reg >= 0);
74	        assert(reg < NUM_REGS);
75	        pmesg(150, "GET_REG %s -> %li\n", regnames[reg], registers[reg]);
pmesg (level=level@entry=150, 
    format=format@entry=0x8055348 "GET_REG %s -> %li\n") at util.c:76
76	void pmesg(int level, const char * format, ...) {
83	        if (level>msglevel)
91	}
get_reg (reg=reg@entry=0) at regsta.c:76
76	        return registers[reg];
77	}
output_glyph (font=font@entry=0, glyph=0) at readdvi.c:152
152	                       font_char_depth(currfont, glyph),
149	        page_set_glyph(font, fnt_convert(currfenc, glyph),
152	                       font_char_depth(currfont, glyph),
font_char_depth (font=0, glyph=glyph@entry=0) at fontinfo.c:489
489	{
492	        if (glyph < 0) {
498	        if (font < 0 || font >= LEN_TFM_TBL) {
503	        if (ugly < tfm_tbl[font].bc || ugly > tfm_tbl[font].ec) {
508	        de = tfm_tbl[font].char_info[ugly - tfm_tbl[font].bc].depth_index;

Program received signal SIGSEGV, Segmentation fault.
0x08049cd4 in font_char_depth (font=0, glyph=glyph@entry=0) at fontinfo.c:508
508	        de = tfm_tbl[font].char_info[ugly - tfm_tbl[font].bc].depth_index;
